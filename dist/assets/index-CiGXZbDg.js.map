{"version":3,"file":"index-CiGXZbDg.js","sources":["../../src/Config.ts","../../src/managers/ScoreManager.ts","../../src/scenes/MenuScene.ts","../../src/managers/InputManager.ts","../../src/managers/AudioManager.ts","../../src/utils/Utils.ts","../../src/managers/PlayerController.ts","../../src/managers/EnemyManager.ts","../../src/managers/SpiderManager.ts","../../src/managers/UIManager.ts","../../src/managers/GameStateManager.ts","../../src/systems/CollisionSystem.ts","../../src/systems/MazeGenerator.ts","../../src/systems/GridRenderer.ts","../../src/scenes/GameScene.ts","../../src/main.ts"],"sourcesContent":["import type { GameConfig } from './types/game.types';\r\n\r\nexport const CONFIG: GameConfig = {\r\n    // Configuraci√≥n del juego\r\n    GAME_WIDTH: 600,\r\n    GAME_HEIGHT: 600,\r\n    BOARD_SIZE: 10,\r\n    CELL_SIZE: 60,\r\n\r\n    // Configuraciones de gameplay\r\n    MAZE_GENERATION: {\r\n        OBSTACLE_PROBABILITY: 0.2,\r\n        COIN_PROBABILITY: 0.1,\r\n        TRAP_PROBABILITY: 0.05,\r\n        MAX_ATTEMPTS: 100,\r\n        MIN_FREE_SPACES: 4\r\n    },\r\n\r\n    // Configuraci√≥n de m√∫sica y audio\r\n    AUDIO: {\r\n        DEFAULT_VOLUME: 0.5,\r\n        MAX_BG_TRACKS: 26\r\n    },\r\n\r\n    // UI y efectos visuales\r\n    UI: {\r\n        GAME_OVER_FONT_SIZE: '48px',\r\n        RESTART_FONT_SIZE: '24px',\r\n        RESTART_OFFSET_Y: 80,\r\n        EXIT_BLINK_ALPHA_HIGH: 1,\r\n        EXIT_BLINK_ALPHA_LOW: 0.3,\r\n        EXIT_BLINK_INTERVAL: 200,\r\n        FONT_FAMILY: '\"Press Start 2P\", cursive',\r\n        MAIN_BACKGROUND_COLOR: '#1e1e2e'\r\n    },\r\n\r\n    // Colores de NE√ìN por nivel\r\n    BACKGROUND_COLORS: [0x4CC9F0, 0xF72585, 0x4AD66D, 0xF4D35E, 0x7209B7],\r\n    GRID_ALPHA: 0.15,\r\n\r\n    // Configuraci√≥n de enemigos\r\n    ENEMIES: {\r\n        MIN_LEVEL_FOR_TWO: 10,\r\n        SINGLE_COUNT: 1,\r\n        DOUBLE_COUNT: 2,\r\n        MOVE_TWEEN_DURATION_MS: 1000,\r\n        FIRST_SPAWN_LEVEL: 5,\r\n        SECOND_ENEMY_INTERVAL: 7,\r\n        MAX_COUNT: 4\r\n    },\r\n\r\n    // Configuraci√≥n de ara√±as\r\n    SPIDER: {\r\n        MIN_PATROL_DISTANCE: 3,\r\n        WAIT_DURATION_MS: 2000,\r\n        MOVE_SPEED: 0.05,\r\n        FIRST_SPAWN_LEVEL: 10,\r\n        SECOND_SPAWN_LEVEL: 15,\r\n        THIRD_SPAWN_LEVEL: 20\r\n    },\r\n\r\n    // Configuraci√≥n de power-ups\r\n    POWERUPS: {\r\n        SPAWN_COIN_RATIO: 0.8,\r\n        SHIELD_PROBABILITY: 0.8,\r\n        SHIELD_INVINCIBILITY_MS: 500 // Invincibility window after shield use\r\n    },\r\n\r\n    PERFORMANCE: {\r\n        INPUT_THROTTLE_MS: 16,\r\n        ENEMY_UPDATE_THROTTLE_MS: 16,\r\n        PLAYER_MIN_STEP_DURATION_MS: 60,      // Velocidad m√°xima absoluta\r\n        PLAYER_BASE_DURATION_MS: 400,         // Velocidad inicial\r\n        PLAYER_STEP_DEC_PER_LEVEL: 20,        // Fase 1: -20ms por nivel (1-10)\r\n        PLAYER_STEP_DEC_SLOW: 5,              // Fase 2: -5ms por nivel (11-34)\r\n        PLAYER_STEP_DEC_TINY: 1,              // Fase 3: -1ms por nivel (35+)\r\n        PLAYER_PHASE1_MAX_LEVEL: 10,          // Fase 1 termina en nivel 10\r\n        PLAYER_PHASE2_MAX_LEVEL: 34           // Fase 2 termina en nivel 34\r\n    },\r\n\r\n    DEBUG: false\r\n};\r\n","const HIGH_SCORE_KEY = 'lucys_maze_high_score';\r\n\r\nexport class ScoreManager {\r\n    /**\r\n     * Get the current high score from localStorage\r\n     */\r\n    static getHighScore(): number {\r\n        try {\r\n            const stored = localStorage.getItem(HIGH_SCORE_KEY);\r\n            return stored ? parseInt(stored, 10) : 0;\r\n        } catch {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save a new high score if it beats the current record\r\n     */\r\n    static setHighScore(score: number): boolean {\r\n        try {\r\n            const current = this.getHighScore();\r\n            if (score > current) {\r\n                localStorage.setItem(HIGH_SCORE_KEY, score.toString());\r\n                return true;\r\n            }\r\n            return false;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a score is a new high score\r\n     */\r\n    static isNewHighScore(score: number): boolean {\r\n        return score > this.getHighScore();\r\n    }\r\n\r\n    /**\r\n     * Reset the high score (for testing)\r\n     */\r\n    static reset(): void {\r\n        try {\r\n            localStorage.removeItem(HIGH_SCORE_KEY);\r\n        } catch {\r\n            // Ignore errors\r\n        }\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { ScoreManager } from '../managers/ScoreManager';\r\n\r\nexport interface DevModeData {\r\n    enabled: boolean;\r\n    level: number;\r\n    shields: number;\r\n    continues: number;\r\n    score: number;\r\n}\r\n\r\nexport class MenuScene extends Phaser.Scene {\r\n    private devModeData: DevModeData = {\r\n        enabled: false,\r\n        level: 1,\r\n        shields: 0,\r\n        continues: 0,\r\n        score: 0\r\n    };\r\n\r\n    private devPanel: Phaser.GameObjects.Container | null = null;\r\n    private devTexts: { [key: string]: Phaser.GameObjects.Text } = {};\r\n\r\n    constructor() {\r\n        super('MenuScene');\r\n    }\r\n\r\n    preload() {\r\n        // Load player image for logo\r\n        this.load.image('player_stand', 'lucy_stand.png');\r\n    }\r\n\r\n    create() {\r\n        const centerX = CONFIG.GAME_WIDTH / 2;\r\n        const centerY = CONFIG.GAME_HEIGHT / 2;\r\n\r\n        // Background\r\n        this.cameras.main.setBackgroundColor(CONFIG.UI.MAIN_BACKGROUND_COLOR);\r\n\r\n        // Title - neon theme colors matching the game\r\n        const title = this.add.text(centerX, centerY - 180, \"LUCY'S MAZE\", {\r\n            fontSize: '32px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#F72585',\r\n            stroke: '#ff6600',\r\n            strokeThickness: 3\r\n        });\r\n        title.setOrigin(0.5);\r\n\r\n        // Subtitle with neon cyan\r\n        const subtitle = this.add.text(centerX, centerY - 130, '¬°Ayuda a Lucy a encontrar la salida!', {\r\n            fontSize: '14px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#4CC9F0'\r\n        });\r\n        subtitle.setOrigin(0.5);\r\n\r\n        // Player sprite as logo\r\n        const playerLogo = this.add.sprite(centerX, centerY + 60, 'player_stand');\r\n        playerLogo.setScale(3);\r\n        playerLogo.setOrigin(0.5, 1);  // Origin at feet so animation scales from bottom\r\n\r\n        // Subtle breathing/idle animation - feet stay grounded\r\n        this.tweens.add({\r\n            targets: playerLogo,\r\n            scaleY: 3.08,         // Slight vertical stretch (breathing in)\r\n            scaleX: 2.95,         // Slight horizontal compress\r\n            duration: 1200,\r\n            yoyo: true,\r\n            repeat: -1,\r\n            ease: 'Sine.InOut'\r\n        });\r\n\r\n        // Play button\r\n        const playButton = this.add.text(centerX, centerY + 80, '‚ñ∂ JUGAR', {\r\n            fontSize: '24px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#00ff00',\r\n            backgroundColor: '#003300',\r\n            padding: { x: 30, y: 15 }\r\n        });\r\n        playButton.setOrigin(0.5);\r\n        playButton.setInteractive({ useHandCursor: true });\r\n\r\n        // Hover effects\r\n        playButton.on('pointerover', () => {\r\n            playButton.setStyle({ color: '#ffffff', backgroundColor: '#006600' });\r\n            playButton.setScale(1.1);\r\n        });\r\n        playButton.on('pointerout', () => {\r\n            playButton.setStyle({ color: '#00ff00', backgroundColor: '#003300' });\r\n            playButton.setScale(1);\r\n        });\r\n        playButton.on('pointerdown', () => {\r\n            this.startGame();\r\n        });\r\n\r\n        // High score display\r\n        const highScore = ScoreManager.getHighScore();\r\n        const highScoreText = this.add.text(centerX, centerY + 160, `R√âCORD: ${highScore}`, {\r\n            fontSize: '16px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#ff00ff'\r\n        });\r\n        highScoreText.setOrigin(0.5);\r\n\r\n        // Instructions\r\n        const instructions = this.add.text(centerX, centerY + 220, 'Usa las flechas ‚Üê ‚Üë ‚Üí ‚Üì o desliza', {\r\n            fontSize: '12px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#888888'\r\n        });\r\n        instructions.setOrigin(0.5);\r\n\r\n        // Dev Mode button (small, in corner)\r\n        const devButton = this.add.text(CONFIG.GAME_WIDTH - 10, 10, 'üîß DEV', {\r\n            fontSize: '12px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#666666',\r\n            backgroundColor: '#222222',\r\n            padding: { x: 8, y: 4 }\r\n        });\r\n        devButton.setOrigin(1, 0);\r\n        devButton.setInteractive({ useHandCursor: true });\r\n        devButton.on('pointerover', () => devButton.setStyle({ color: '#ffffff' }));\r\n        devButton.on('pointerout', () => devButton.setStyle({ color: '#666666' }));\r\n        devButton.on('pointerdown', () => this.toggleDevPanel());\r\n\r\n        // Allow starting with Enter or Space\r\n        this.input.keyboard.on('keydown-ENTER', () => this.startGame());\r\n        this.input.keyboard.on('keydown-SPACE', () => this.startGame());\r\n\r\n        // Touch to start\r\n        this.input.on('pointerdown', (pointer) => {\r\n            // Only start if not clicking the button\r\n            if (pointer.y < centerY + 50 || pointer.y > centerY + 120) {\r\n                // Do nothing, let button handle it\r\n            }\r\n        });\r\n    }\r\n\r\n    private toggleDevPanel(): void {\r\n        if (this.devPanel) {\r\n            this.devPanel.destroy();\r\n            this.devPanel = null;\r\n            return;\r\n        }\r\n\r\n        const panelX = CONFIG.GAME_WIDTH / 2;\r\n        const panelY = CONFIG.GAME_HEIGHT / 2;\r\n\r\n        this.devPanel = this.add.container(panelX, panelY);\r\n\r\n        // Panel background\r\n        const bg = this.add.graphics();\r\n        bg.fillStyle(0x1a1a2e, 0.95);\r\n        bg.fillRoundedRect(-150, -130, 300, 260, 10);\r\n        bg.lineStyle(2, 0x4CC9F0);\r\n        bg.strokeRoundedRect(-150, -130, 300, 260, 10);\r\n        this.devPanel.add(bg);\r\n\r\n        // Title\r\n        const title = this.add.text(0, -110, 'üîß DEV MODE', {\r\n            fontSize: '16px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#4CC9F0'\r\n        });\r\n        title.setOrigin(0.5);\r\n        this.devPanel.add(title);\r\n\r\n        // Create value rows\r\n        const rows = [\r\n            { key: 'level', label: 'Nivel', min: 1, max: 50 },\r\n            { key: 'shields', label: 'Shields', min: 0, max: 10 },\r\n            { key: 'continues', label: 'Continues', min: 0, max: 10 },\r\n            { key: 'score', label: 'Puntaje', min: 0, max: 10000, step: 100 }\r\n        ];\r\n\r\n        rows.forEach((row, index) => {\r\n            const y = -60 + index * 45;\r\n\r\n            // Label\r\n            const label = this.add.text(-120, y, row.label, {\r\n                fontSize: '12px',\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#ffffff'\r\n            });\r\n            this.devPanel!.add(label);\r\n\r\n            // Minus button\r\n            const minus = this.add.text(30, y, '-', {\r\n                fontSize: '20px',\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#ff6666',\r\n                backgroundColor: '#330000',\r\n                padding: { x: 10, y: 2 }\r\n            });\r\n            minus.setInteractive({ useHandCursor: true });\r\n            minus.on('pointerdown', () => {\r\n                const step = row.step || 1;\r\n                (this.devModeData as any)[row.key] = Math.max(row.min, (this.devModeData as any)[row.key] - step);\r\n                this.updateDevText(row.key);\r\n            });\r\n            this.devPanel!.add(minus);\r\n\r\n            // Value\r\n            const value = this.add.text(75, y, String((this.devModeData as any)[row.key]), {\r\n                fontSize: '14px',\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#00ff00'\r\n            });\r\n            value.setOrigin(0.5, 0);\r\n            this.devTexts[row.key] = value;\r\n            this.devPanel!.add(value);\r\n\r\n            // Plus button\r\n            const plus = this.add.text(100, y, '+', {\r\n                fontSize: '20px',\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#66ff66',\r\n                backgroundColor: '#003300',\r\n                padding: { x: 10, y: 2 }\r\n            });\r\n            plus.setInteractive({ useHandCursor: true });\r\n            plus.on('pointerdown', () => {\r\n                const step = row.step || 1;\r\n                (this.devModeData as any)[row.key] = Math.min(row.max, (this.devModeData as any)[row.key] + step);\r\n                this.updateDevText(row.key);\r\n            });\r\n            this.devPanel!.add(plus);\r\n        });\r\n\r\n        // Apply button\r\n        const applyBtn = this.add.text(0, 100, '‚úì INICIAR CON ESTOS VALORES', {\r\n            fontSize: '12px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#00ff00',\r\n            backgroundColor: '#004400',\r\n            padding: { x: 15, y: 8 }\r\n        });\r\n        applyBtn.setOrigin(0.5);\r\n        applyBtn.setInteractive({ useHandCursor: true });\r\n        applyBtn.on('pointerover', () => applyBtn.setStyle({ backgroundColor: '#006600' }));\r\n        applyBtn.on('pointerout', () => applyBtn.setStyle({ backgroundColor: '#004400' }));\r\n        applyBtn.on('pointerdown', () => {\r\n            this.devModeData.enabled = true;\r\n            this.startGame();\r\n        });\r\n        this.devPanel.add(applyBtn);\r\n\r\n        this.devPanel.setDepth(100);\r\n    }\r\n\r\n    private updateDevText(key: string): void {\r\n        if (this.devTexts[key]) {\r\n            this.devTexts[key].setText(String((this.devModeData as any)[key]));\r\n        }\r\n    }\r\n\r\n    startGame() {\r\n        this.cameras.main.fadeOut(300, 0, 0, 0);\r\n        this.time.delayedCall(300, () => {\r\n            this.scene.start('GameScene', this.devModeData.enabled ? this.devModeData : null);\r\n        });\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport type { Direction } from '../types/game.types';\r\n\r\n/**\r\n * Gestor de entrada para controles de teclado y touch\r\n * Emite eventos cuando se detecta input direccional\r\n */\r\nexport class InputManager {\r\n    private scene: Phaser.Scene;\r\n    private cursors: Phaser.Types.Input.Keyboard.CursorKeys;\r\n    private restartKey: Phaser.Input.Keyboard.Key;\r\n    private menuKey: Phaser.Input.Keyboard.Key;\r\n    private continueKey: Phaser.Input.Keyboard.Key;\r\n    private desiredDirection: Direction = { dx: 0, dy: 0 };\r\n    private swipeStartX: number = 0;\r\n    private swipeStartY: number = 0;\r\n    private readonly minSwipeDistance: number = 30;\r\n\r\n    constructor(scene: Phaser.Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Inicializa todos los controles\r\n     */\r\n    setup(): void {\r\n        this.setupKeyboardControls();\r\n        this.setupTouchControls();\r\n    }\r\n\r\n    /**\r\n     * Configura los controles de teclado\r\n     */\r\n    private setupKeyboardControls(): void {\r\n        this.cursors = this.scene.input.keyboard!.createCursorKeys();\r\n        this.restartKey = this.scene.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.R);\r\n        this.menuKey = this.scene.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.M);\r\n        this.continueKey = this.scene.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.C);\r\n\r\n        this.scene.input.keyboard!.on('keydown', (event: KeyboardEvent) => {\r\n            switch (event.code) {\r\n                case 'ArrowLeft':\r\n                    this.desiredDirection = { dx: -1, dy: 0 };\r\n                    break;\r\n                case 'ArrowRight':\r\n                    this.desiredDirection = { dx: 1, dy: 0 };\r\n                    break;\r\n                case 'ArrowUp':\r\n                    this.desiredDirection = { dx: 0, dy: -1 };\r\n                    break;\r\n                case 'ArrowDown':\r\n                    this.desiredDirection = { dx: 0, dy: 1 };\r\n                    break;\r\n                default:\r\n                    return; // Don't emit event for other keys\r\n            }\r\n\r\n            this.scene.events.emit('input:direction', this.desiredDirection);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Configura los controles t√°ctiles (swipe)\r\n     */\r\n    private setupTouchControls(): void {\r\n        this.scene.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\r\n            this.swipeStartX = pointer.x;\r\n            this.swipeStartY = pointer.y;\r\n        });\r\n\r\n        this.scene.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {\r\n            const dx = pointer.x - this.swipeStartX;\r\n            const dy = pointer.y - this.swipeStartY;\r\n            const absDx = Math.abs(dx);\r\n            const absDy = Math.abs(dy);\r\n\r\n            if (Math.max(absDx, absDy) < this.minSwipeDistance) return;\r\n\r\n            if (absDx > absDy) {\r\n                this.desiredDirection = { dx: dx > 0 ? 1 : -1, dy: 0 };\r\n            } else {\r\n                this.desiredDirection = { dx: 0, dy: dy > 0 ? 1 : -1 };\r\n            }\r\n\r\n            this.scene.events.emit('input:direction', this.desiredDirection);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si la tecla R fue presionada (para restart)\r\n     */\r\n    isRestartJustPressed(): boolean {\r\n        return Phaser.Input.Keyboard.JustDown(this.restartKey);\r\n    }\r\n\r\n    /**\r\n     * Verifica si la tecla M fue presionada (para men√∫)\r\n     */\r\n    isMenuJustPressed(): boolean {\r\n        return Phaser.Input.Keyboard.JustDown(this.menuKey);\r\n    }\r\n\r\n    /**\r\n     * Verifica si la tecla C fue presionada (para continuar con power-up)\r\n     */\r\n    isContinueJustPressed(): boolean {\r\n        return Phaser.Input.Keyboard.JustDown(this.continueKey);\r\n    }\r\n\r\n    /**\r\n     * Obtiene la direcci√≥n deseada actual\r\n     */\r\n    getDesiredDirection(): Direction {\r\n        return this.desiredDirection;\r\n    }\r\n\r\n    /**\r\n     * Resetea la direcci√≥n deseada\r\n     */\r\n    resetDesiredDirection(): void {\r\n        this.desiredDirection = { dx: 0, dy: 0 };\r\n    }\r\n\r\n    /**\r\n     * Limpieza de recursos\r\n     */\r\n    destroy(): void {\r\n        this.scene.input.keyboard?.off('keydown');\r\n        this.scene.input.off('pointerdown');\r\n        this.scene.input.off('pointerup');\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\n\r\n/**\r\n * Gestor de audio para m√∫sica de fondo con playlist\r\n */\r\nexport class AudioManager {\r\n    private scene: Phaser.Scene;\r\n    private availableMusicKeys: string[] = [];\r\n    private backgroundMusic: Phaser.Sound.BaseSound | null = null;\r\n    private musicPlaylistOrder: string[] = [];\r\n    private currentPlaylistIndex: number = 0;\r\n\r\n    constructor(scene: Phaser.Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Detecta y carga archivos de m√∫sica en preload\r\n     */\r\n    detectAndLoadMusic(): void {\r\n        this.availableMusicKeys = [];\r\n        const maxTracks = CONFIG.AUDIO.MAX_BG_TRACKS;\r\n\r\n        // Setup error handling\r\n        this.scene.load.on('loaderror', (file: Phaser.Loader.File) => {\r\n            if (file.key.startsWith('backgroundMusic')) {\r\n                const keyIndex = this.availableMusicKeys.indexOf(file.key);\r\n                if (keyIndex > -1) {\r\n                    this.availableMusicKeys.splice(keyIndex, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.scene.load.on('filecomplete', (key: string) => {\r\n            if (key.startsWith('backgroundMusic')) {\r\n                if (!this.availableMusicKeys.includes(key)) {\r\n                    this.availableMusicKeys.push(key);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Queue music files for loading OR add existing ones\r\n        for (let i = 1; i <= maxTracks; i++) {\r\n            const paddedNumber = i.toString().padStart(3, '0');\r\n            const filename = `bg_${paddedNumber}.mp3`;\r\n            const key = `backgroundMusic${i - 1}`;\r\n\r\n            // Check if already in cache (crucial for restarts/scene switches)\r\n            if (this.scene.cache.audio.exists(key)) {\r\n                if (!this.availableMusicKeys.includes(key)) {\r\n                    this.availableMusicKeys.push(key);\r\n                }\r\n                continue; // Skip loading if already exists\r\n            }\r\n\r\n            try {\r\n                this.scene.load.audio(key, `sound/bg/${filename}`);\r\n            } catch (error) {\r\n                console.warn('Could not queue music file:', filename, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inicializa y comienza la reproducci√≥n de m√∫sica\r\n     */\r\n    initMusic(): void {\r\n        const tryStartMusic = () => {\r\n            if (this.availableMusicKeys.length > 0) {\r\n                this.shufflePlaylist();\r\n                this.playNext();\r\n            } else {\r\n                this.scene.time.delayedCall(500, () => {\r\n                    if (this.availableMusicKeys.length > 0) {\r\n                        this.shufflePlaylist();\r\n                        this.playNext();\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        if (this.scene.sound.locked) {\r\n            this.scene.input.once('pointerdown', () => this.scene.sound.unlock());\r\n            if (this.scene.input.keyboard) {\r\n                this.scene.input.keyboard.once('keydown', () => this.scene.sound.unlock());\r\n            }\r\n            this.scene.sound.once('unlocked', tryStartMusic);\r\n        } else {\r\n            this.scene.time.delayedCall(200, tryStartMusic);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mezcla el orden de reproducci√≥n\r\n     */\r\n    shufflePlaylist(): void {\r\n        if (this.availableMusicKeys.length === 0) {\r\n            this.musicPlaylistOrder = [];\r\n            this.currentPlaylistIndex = 0;\r\n            return;\r\n        }\r\n\r\n        this.musicPlaylistOrder = [...this.availableMusicKeys];\r\n        for (let i = this.musicPlaylistOrder.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            [this.musicPlaylistOrder[i], this.musicPlaylistOrder[j]] =\r\n                [this.musicPlaylistOrder[j], this.musicPlaylistOrder[i]];\r\n        }\r\n        this.currentPlaylistIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Reproduce la siguiente canci√≥n en la playlist\r\n     */\r\n    playNext(): void {\r\n        if (this.availableMusicKeys.length === 0) return;\r\n\r\n        this.stop();\r\n\r\n        if (this.currentPlaylistIndex >= this.musicPlaylistOrder.length) {\r\n            this.shufflePlaylist();\r\n        }\r\n\r\n        const musicKey = this.musicPlaylistOrder[this.currentPlaylistIndex];\r\n        this.currentPlaylistIndex++;\r\n\r\n        this.playSpecific(musicKey);\r\n    }\r\n\r\n    /**\r\n     * Reproduce la canci√≥n anterior\r\n     */\r\n    playPrevious(): void {\r\n        if (this.availableMusicKeys.length === 0) return;\r\n        this.currentPlaylistIndex = Math.max(0, this.currentPlaylistIndex - 2);\r\n        this.playNext();\r\n    }\r\n\r\n    /**\r\n     * Reproduce una canci√≥n espec√≠fica\r\n     */\r\n    private playSpecific(musicKey: string): void {\r\n        try {\r\n            if (!this.scene.cache.audio.exists(musicKey)) return;\r\n\r\n            this.backgroundMusic = this.scene.sound.add(musicKey, {\r\n                loop: false,\r\n                volume: CONFIG.AUDIO.DEFAULT_VOLUME\r\n            });\r\n\r\n            this.backgroundMusic.play();\r\n            this.backgroundMusic.once('complete', () => {\r\n                this.playNext();\r\n            });\r\n        } catch (error) {\r\n            console.error('Error in playSpecific:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pausa/Reanuda la m√∫sica\r\n     */\r\n    togglePlayPause(): void {\r\n        const soundManager = this.scene.sound as Phaser.Sound.WebAudioSoundManager;\r\n        if (soundManager?.context?.state === 'suspended') {\r\n            soundManager.context.resume().catch(() => { });\r\n        }\r\n\r\n        if (this.backgroundMusic?.isPlaying) {\r\n            this.backgroundMusic.pause();\r\n        } else if (this.backgroundMusic) {\r\n            this.backgroundMusic.resume();\r\n        } else {\r\n            this.playNext();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detiene la m√∫sica actual\r\n     */\r\n    stop(): void {\r\n        if (this.backgroundMusic) {\r\n            this.backgroundMusic.stop();\r\n            this.backgroundMusic.destroy();\r\n            this.backgroundMusic = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Establece el volumen\r\n     */\r\n    setVolume(volume: number): void {\r\n        if (this.backgroundMusic && 'setVolume' in this.backgroundMusic) {\r\n            (this.backgroundMusic as Phaser.Sound.WebAudioSound).setVolume(volume);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifica si hay m√∫sica reproduci√©ndose\r\n     */\r\n    isPlaying(): boolean {\r\n        return this.backgroundMusic?.isPlaying ?? false;\r\n    }\r\n\r\n\r\n    /**\r\n     * Limpieza de recursos\r\n     */\r\n    destroy(): void {\r\n        this.stop();\r\n        this.scene.load.off('loaderror');\r\n        this.scene.load.off('filecomplete');\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport type { Position } from '../types/game.types';\r\n\r\n/**\r\n * Calcula la escala √≥ptima para un sprite basado en el tama√±o de celda\r\n * @param textureKey - Clave de la textura en Phaser\r\n * @param targetSize - Tama√±o objetivo (generalmente cellSize)\r\n * @param scene - Escena de Phaser para acceder a texturas\r\n * @returns Factor de escala calculado\r\n */\r\nexport function calculateSpriteScale(\r\n    textureKey: string,\r\n    targetSize: number,\r\n    scene: Phaser.Scene\r\n): number {\r\n    try {\r\n        if (!scene || !scene.textures || !scene.textures.get(textureKey)) {\r\n            console.warn(`calculateSpriteScale: Invalid texture key \"${textureKey}\"`);\r\n            return 1;\r\n        }\r\n\r\n        const texture = scene.textures.get(textureKey);\r\n        const sourceImage = texture.getSourceImage() as HTMLImageElement;\r\n        const originalWidth = sourceImage.width;\r\n        const originalHeight = sourceImage.height;\r\n\r\n        return Math.min(targetSize / originalWidth, targetSize / originalHeight);\r\n    } catch (error) {\r\n        console.error('Error calculating sprite scale:', error);\r\n        return 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Genera una posici√≥n aleatoria libre en el tablero\r\n * @param excludePositions - Array de posiciones a excluir\r\n * @param boardSize - Tama√±o del tablero\r\n * @returns Posici√≥n libre o null si no se encuentra\r\n */\r\nexport function generateFreePosition(\r\n    excludePositions: Position[] = [],\r\n    boardSize: number\r\n): Position | null {\r\n    if (!Array.isArray(excludePositions)) {\r\n        console.warn('generateFreePosition: excludePositions must be an array');\r\n        excludePositions = [];\r\n    }\r\n\r\n    if (!boardSize || boardSize < 1) {\r\n        console.error('generateFreePosition: Invalid boardSize:', boardSize);\r\n        return null;\r\n    }\r\n\r\n    const maxAttempts = 50;\r\n    let attempts = 0;\r\n\r\n    while (attempts < maxAttempts) {\r\n        const position: Position = {\r\n            x: Math.floor(Math.random() * boardSize),\r\n            y: Math.floor(Math.random() * boardSize)\r\n        };\r\n\r\n        const isOccupied = excludePositions.some(\r\n            pos => pos.x === position.x && pos.y === position.y\r\n        );\r\n\r\n        if (!isOccupied) {\r\n            return position;\r\n        }\r\n\r\n        attempts++;\r\n    }\r\n\r\n    console.warn('generateFreePosition: Could not find free position after', maxAttempts, 'attempts');\r\n    return null;\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale } from '../utils/Utils';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { Position, Direction } from '../types/game.types';\r\n\r\n/**\r\n * Controlador del jugador con movimiento tipo sliding puzzle\r\n * Soporta cambio de direcci√≥n durante el movimiento (turn opportunity)\r\n */\r\nexport class PlayerController {\r\n    private scene: Phaser.Scene;\r\n    private collision: CollisionSystem;\r\n    private cellSize: number;\r\n    private playerPosition: Position = { x: 0, y: 0 };\r\n    private moveDirection: Direction = { dx: 0, dy: 0 };\r\n    private isMoving: boolean = false;\r\n    private playerMoveTween: Phaser.Tweens.Tween | null = null;\r\n\r\n    // Sprites\r\n    private playerSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private playerDieSprite: Phaser.GameObjects.Sprite | null = null;\r\n\r\n    // Particles\r\n    private coinParticles: Phaser.GameObjects.Particles.ParticleEmitter | null = null;\r\n    private trailParticles: Phaser.GameObjects.Particles.ParticleEmitter | null = null;\r\n\r\n    // Callbacks for turn opportunity\r\n    private getDesiredDirection: (() => Direction) | null = null;\r\n    private onTurnMove: ((dx: number, dy: number) => void) | null = null;\r\n\r\n    // Callback for processing items during movement\r\n    private currentStepCallback: ((x: number, y: number) => void) | null = null;\r\n\r\n    constructor(scene: Phaser.Scene, collision: CollisionSystem, cellSize: number) {\r\n        this.scene = scene;\r\n        this.collision = collision;\r\n        this.cellSize = cellSize;\r\n    }\r\n\r\n    /**\r\n     * Configura los callbacks para el cambio de direcci√≥n durante movimiento\r\n     */\r\n    setTurnCallbacks(\r\n        getDesiredDirection: () => Direction,\r\n        onTurnMove: (dx: number, dy: number) => void\r\n    ): void {\r\n        this.getDesiredDirection = getDesiredDirection;\r\n        this.onTurnMove = onTurnMove;\r\n    }\r\n\r\n    /**\r\n     * Crea el sprite del jugador y part√≠culas\r\n     */\r\n    create(position: Position): void {\r\n        this.playerPosition = { ...position };\r\n\r\n        this.playerSprite = this.scene.add.sprite(\r\n            position.x * this.cellSize + this.cellSize / 2,\r\n            position.y * this.cellSize + this.cellSize / 2,\r\n            'player_stand'\r\n        );\r\n        this.playerSprite.setDepth(10);\r\n        this.adjustScaleAndRotation();\r\n\r\n        // Coin particles\r\n        this.coinParticles = this.scene.add.particles(0, 0, 'coin', {\r\n            speed: { min: 50, max: 150 },\r\n            scale: { start: 0.4, end: 0 },\r\n            lifespan: 600,\r\n            blendMode: 'ADD',\r\n            quantity: 10,\r\n            emitting: false\r\n        });\r\n\r\n        // Trail particles\r\n        this.trailParticles = this.scene.add.particles(0, 0, 'player_run', {\r\n            speed: 0,\r\n            scale: { start: calculateSpriteScale('player_run', this.cellSize, this.scene) * 0.9, end: 0.7 },\r\n            alpha: { start: 0.15, end: 0 },\r\n            lifespan: 1000,\r\n            blendMode: 'ADD',\r\n            frequency: 140,\r\n            emitting: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Mueve al jugador en una direcci√≥n hasta encontrar un obst√°culo\r\n     */\r\n    move(\r\n        dx: number,\r\n        dy: number,\r\n        level: number,\r\n        traps: Position[],\r\n        exitPosition: Position,\r\n        checkEnemyCollision: (x: number, y: number) => boolean,\r\n        onStepCallback: (x: number, y: number) => void\r\n    ): void {\r\n        if (this.isMoving || (dx === 0 && dy === 0)) return;\r\n\r\n        this.moveDirection = { dx, dy };\r\n        const moveResult = this.collision.calculateMoveUntilObstacle(\r\n            this.playerPosition.x,\r\n            this.playerPosition.y,\r\n            dx, dy\r\n        );\r\n\r\n        if (moveResult.distance === 0) {\r\n            this.resetMovementState();\r\n            return;\r\n        }\r\n\r\n        this.startMovement();\r\n        this.currentStepCallback = onStepCallback;\r\n        const baseStepDuration = this.calculateStepDuration(level);\r\n        const finalDestination = this.calculateFinalDestination(\r\n            dx, dy, moveResult, traps, exitPosition, checkEnemyCollision\r\n        );\r\n\r\n        this.executeMovementTween(dx, dy, baseStepDuration, finalDestination, traps, exitPosition, checkEnemyCollision, onStepCallback);\r\n    }\r\n\r\n    /**\r\n     * Calcula la duraci√≥n de cada paso basado en el nivel\r\n     * Fase 1 (niveles 1-10): Aceleraci√≥n r√°pida (-20ms por nivel)\r\n     * Fase 2 (niveles 11-34): Aceleraci√≥n moderada (-5ms por nivel)\r\n     * Fase 3 (niveles 35+): Aceleraci√≥n m√≠nima (-1ms por nivel hasta 60ms)\r\n     */\r\n    private calculateStepDuration(level: number): number {\r\n        const baseMs = CONFIG.PERFORMANCE.PLAYER_BASE_DURATION_MS;            // 400ms\r\n        const fastDecPerLevel = CONFIG.PERFORMANCE.PLAYER_STEP_DEC_PER_LEVEL; // 20ms\r\n        const slowDecPerLevel = CONFIG.PERFORMANCE.PLAYER_STEP_DEC_SLOW;      // 5ms\r\n        const tinyDecPerLevel = CONFIG.PERFORMANCE.PLAYER_STEP_DEC_TINY;      // 1ms\r\n        const phase1Limit = CONFIG.PERFORMANCE.PLAYER_PHASE1_MAX_LEVEL;       // 10\r\n        const phase2Limit = CONFIG.PERFORMANCE.PLAYER_PHASE2_MAX_LEVEL;       // 34\r\n        const minMs = CONFIG.PERFORMANCE.PLAYER_MIN_STEP_DURATION_MS;         // 60ms\r\n\r\n        let duration: number;\r\n\r\n        if (level <= phase1Limit) {\r\n            // Fase 1: Aceleraci√≥n r√°pida (niveles 1-10)\r\n            duration = baseMs - level * fastDecPerLevel;\r\n        } else if (level <= phase2Limit) {\r\n            // Fase 2: Aceleraci√≥n moderada (niveles 11-34)\r\n            const phase1Duration = baseMs - phase1Limit * fastDecPerLevel; // 200ms at level 10\r\n            const extraLevels = level - phase1Limit;\r\n            duration = phase1Duration - extraLevels * slowDecPerLevel;\r\n        } else {\r\n            // Fase 3: Aceleraci√≥n m√≠nima (niveles 35+)\r\n            const phase1Duration = baseMs - phase1Limit * fastDecPerLevel; // 200ms\r\n            const phase2Duration = phase1Duration - (phase2Limit - phase1Limit) * slowDecPerLevel; // 80ms at level 34\r\n            const extraLevels = level - phase2Limit;\r\n            duration = phase2Duration - extraLevels * tinyDecPerLevel;\r\n        }\r\n\r\n        return Math.max(minMs, duration);\r\n    }\r\n\r\n    /**\r\n     * Calcula el destino final considerando trampas, enemigos y salida\r\n     */\r\n    private calculateFinalDestination(\r\n        dx: number,\r\n        dy: number,\r\n        moveResult: { x: number; y: number; distance: number },\r\n        traps: Position[],\r\n        exitPosition: Position,\r\n        checkEnemyCollision: (x: number, y: number) => boolean\r\n    ): { x: number; y: number; step: number } {\r\n        const startX = this.playerPosition.x;\r\n        const startY = this.playerPosition.y;\r\n\r\n        for (let i = 1; i <= moveResult.distance; i++) {\r\n            const checkX = startX + (dx * i);\r\n            const checkY = startY + (dy * i);\r\n\r\n            if (this.collision.isTrap(checkX, checkY, traps)) {\r\n                return { x: checkX, y: checkY, step: i };\r\n            }\r\n            if (checkEnemyCollision(checkX, checkY)) {\r\n                return { x: checkX, y: checkY, step: i };\r\n            }\r\n            if (checkX === exitPosition.x && checkY === exitPosition.y) {\r\n                return { x: checkX, y: checkY, step: i };\r\n            }\r\n        }\r\n\r\n        return { x: moveResult.x, y: moveResult.y, step: moveResult.distance };\r\n    }\r\n\r\n    /**\r\n     * Ejecuta el tween de movimiento\r\n     */\r\n    private executeMovementTween(\r\n        dx: number,\r\n        dy: number,\r\n        baseStepDuration: number,\r\n        finalDestination: { x: number; y: number; step: number },\r\n        traps: Position[],\r\n        exitPosition: Position,\r\n        checkEnemyCollision: (x: number, y: number) => boolean,\r\n        onStepCallback: (x: number, y: number) => void\r\n    ): void {\r\n        const startX = this.playerPosition.x;\r\n        const startY = this.playerPosition.y;\r\n        let lastStepProcessed = -1;\r\n\r\n        this.playerMoveTween = this.scene.tweens.add({\r\n            targets: this.playerSprite,\r\n            x: finalDestination.x * this.cellSize + this.cellSize / 2,\r\n            y: finalDestination.y * this.cellSize + this.cellSize / 2,\r\n            duration: baseStepDuration * finalDestination.step,\r\n            ease: 'Linear',\r\n            onUpdate: (tween) => {\r\n                const progress = tween.progress;\r\n                const currentStep = Math.floor(progress * finalDestination.step);\r\n                const stepStart = Math.max(0, lastStepProcessed + 1);\r\n\r\n                for (let step = stepStart; step <= currentStep; step++) {\r\n                    const newX = startX + (dx * step);\r\n                    const newY = startY + (dy * step);\r\n\r\n                    if (newX !== this.playerPosition.x || newY !== this.playerPosition.y) {\r\n                        this.playerPosition.x = newX;\r\n                        this.playerPosition.y = newY;\r\n                        onStepCallback(newX, newY);\r\n\r\n                        // Check death conditions\r\n                        if (this.collision.isTrap(newX, newY, traps) ||\r\n                            checkEnemyCollision(newX, newY)) {\r\n                            // Emit event - GameScene.handleDeath() will use shield or set gameOver\r\n                            this.scene.events.emit('player:died');\r\n                            // After event, check if game is over (shield wasn't available)\r\n                            // If shield absorbed, continue movement with flash effect\r\n                            // Access gameState via scene's registry or event result\r\n                            const gameState = (this.scene as any).gameState;\r\n                            if (gameState?.isGameOver) {\r\n                                return; // Real death - stop movement\r\n                            }\r\n                            // Shield absorbed - continue movement (flash already triggered in handleDeath)\r\n                        }\r\n\r\n                        // Check exit\r\n                        if (newX === exitPosition.x && newY === exitPosition.y) {\r\n                            this.scene.events.emit('player:reachedExit');\r\n                            return;\r\n                        }\r\n\r\n                        // Check for turn opportunity (original logic)\r\n                        if (this.checkTurnOpportunity(tween)) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                lastStepProcessed = currentStep;\r\n            },\r\n            onComplete: () => {\r\n                this.onMovementComplete(finalDestination, traps, exitPosition);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si el jugador puede girar en la posici√≥n actual\r\n     * Esta es la l√≥gica original que permite cambiar de direcci√≥n durante el movimiento\r\n     */\r\n    private checkTurnOpportunity(tween: Phaser.Tweens.Tween): boolean {\r\n        if (!this.getDesiredDirection || !this.onTurnMove) return false;\r\n\r\n        const desiredDirection = this.getDesiredDirection();\r\n\r\n        // Check if there's a desired direction different from current move direction\r\n        if ((desiredDirection.dx !== 0 || desiredDirection.dy !== 0) &&\r\n            (desiredDirection.dx !== this.moveDirection.dx ||\r\n                desiredDirection.dy !== this.moveDirection.dy)) {\r\n\r\n            const turnNextX = this.playerPosition.x + desiredDirection.dx;\r\n            const turnNextY = this.playerPosition.y + desiredDirection.dy;\r\n\r\n            // If turn direction is not blocked, execute turn\r\n            if (!this.collision.isCollision(turnNextX, turnNextY)) {\r\n                // Snap sprite to current grid position\r\n                this.playerSprite?.setPosition(\r\n                    this.playerPosition.x * this.cellSize + this.cellSize / 2,\r\n                    this.playerPosition.y * this.cellSize + this.cellSize / 2\r\n                );\r\n\r\n                // Stop current movement\r\n                tween.stop();\r\n                this.isMoving = false;\r\n\r\n                // Trigger new movement in desired direction\r\n                this.onTurnMove(desiredDirection.dx, desiredDirection.dy);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Finaliza el movimiento\r\n     */\r\n    private onMovementComplete(\r\n        finalDestination: { x: number; y: number; step: number },\r\n        traps: Position[],\r\n        exitPosition: Position\r\n    ): void {\r\n        if (this.trailParticles) this.trailParticles.stop();\r\n\r\n        this.playerPosition.x = finalDestination.x;\r\n        this.playerPosition.y = finalDestination.y;\r\n\r\n        if (finalDestination.step > 0) {\r\n            this.scene.cameras.main.shake(100, 0.005);\r\n        }\r\n\r\n        // Process items at final position (coins, power-ups)\r\n        if (this.currentStepCallback) {\r\n            this.currentStepCallback(this.playerPosition.x, this.playerPosition.y);\r\n        }\r\n\r\n        // Check trap at final position\r\n        if (this.collision.isTrap(this.playerPosition.x, this.playerPosition.y, traps)) {\r\n            this.scene.events.emit('player:died');\r\n            // Check if game is over (shield wasn't available)\r\n            const gameState = (this.scene as any).gameState;\r\n            if (gameState?.isGameOver) {\r\n                return; // Real death\r\n            }\r\n            // Shield absorbed - continue to reset movement state\r\n        }\r\n\r\n        if (this.playerPosition.x === exitPosition.x &&\r\n            this.playerPosition.y === exitPosition.y) {\r\n            this.scene.events.emit('player:reachedExit');\r\n            return;\r\n        }\r\n\r\n        this.isMoving = false;\r\n        this.playerMoveTween = null;\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n        this.playerSprite?.setTexture('player_stand');\r\n        this.adjustScaleAndRotation();\r\n    }\r\n\r\n    /**\r\n     * Inicia el estado de movimiento\r\n     */\r\n    private startMovement(): void {\r\n        this.isMoving = true;\r\n        this.playerSprite?.setTexture('player_run');\r\n        this.adjustScaleAndRotation();\r\n\r\n        if (this.trailParticles && this.playerSprite) {\r\n            this.trailParticles.start();\r\n            this.trailParticles.startFollow(this.playerSprite);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resetea el estado de movimiento\r\n     */\r\n    private resetMovementState(): void {\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n        this.playerSprite?.setTexture('player_stand');\r\n        this.adjustScaleAndRotation();\r\n    }\r\n\r\n    /**\r\n     * Ajusta la escala y rotaci√≥n del sprite seg√∫n la direcci√≥n\r\n     */\r\n    private adjustScaleAndRotation(): void {\r\n        if (!this.playerSprite) return;\r\n\r\n        const playerScale = calculateSpriteScale(this.playerSprite.texture.key, this.cellSize, this.scene);\r\n        this.playerSprite.setScale(playerScale);\r\n\r\n        if (this.moveDirection.dx === 1) {\r\n            this.playerSprite.setAngle(0);\r\n            this.playerSprite.setFlipX(false);\r\n        } else if (this.moveDirection.dx === -1) {\r\n            this.playerSprite.setAngle(0);\r\n            this.playerSprite.setFlipX(true);\r\n        } else if (this.moveDirection.dy === -1) {\r\n            this.playerSprite.setAngle(-90);\r\n            this.playerSprite.setFlipX(false);\r\n        } else if (this.moveDirection.dy === 1) {\r\n            this.playerSprite.setAngle(90);\r\n            this.playerSprite.setFlipX(false);\r\n        } else {\r\n            // Default orientation (facing right)\r\n            this.playerSprite.setAngle(0);\r\n            this.playerSprite.setFlipX(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emite part√≠culas de moneda recogida\r\n     */\r\n    emitCoinParticles(x: number, y: number): void {\r\n        if (this.coinParticles) {\r\n            this.coinParticles.emitParticleAt(\r\n                x * this.cellSize + this.cellSize / 2,\r\n                y * this.cellSize + this.cellSize / 2\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Efecto de parpadeo cuando el shield absorbe un golpe\r\n     * Lucy sigue movi√©ndose pero parpadea brevemente\r\n     */\r\n    flashInvincibility(): void {\r\n        if (!this.playerSprite) return;\r\n\r\n        // Blink effect with tint\r\n        this.scene.tweens.add({\r\n            targets: this.playerSprite,\r\n            alpha: { from: 1, to: 0.3 },\r\n            duration: 80,\r\n            yoyo: true,\r\n            repeat: 4,\r\n            onComplete: () => {\r\n                this.playerSprite?.setAlpha(1);\r\n            }\r\n        });\r\n\r\n        // Blue tint flash\r\n        this.playerSprite.setTint(0x00bfff);\r\n        this.scene.time.delayedCall(400, () => {\r\n            this.playerSprite?.clearTint();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Muestra el sprite de muerte\r\n     */\r\n    showDeathSprite(): void {\r\n        if (this.playerSprite) {\r\n            this.playerSprite.destroy();\r\n            this.playerSprite = null;\r\n        }\r\n\r\n        this.playerDieSprite = this.scene.add.sprite(\r\n            this.playerPosition.x * this.cellSize + this.cellSize / 2,\r\n            this.playerPosition.y * this.cellSize + this.cellSize / 2,\r\n            'player_die'\r\n        );\r\n        const dieScale = calculateSpriteScale('player_die', this.cellSize, this.scene);\r\n        this.playerDieSprite.setScale(dieScale);\r\n    }\r\n\r\n    /**\r\n     * Detiene el movimiento actual\r\n     */\r\n    stopMovement(): void {\r\n        if (this.playerMoveTween) {\r\n            this.playerMoveTween.stop();\r\n            this.playerMoveTween = null;\r\n        }\r\n        this.isMoving = false;\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n        if (this.trailParticles) this.trailParticles.stop();\r\n    }\r\n\r\n    /**\r\n     * Resetea el jugador a una posici√≥n\r\n     */\r\n    reset(position: Position): void {\r\n        this.playerPosition = { ...position };\r\n        this.isMoving = false;\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n\r\n        if (this.playerMoveTween) {\r\n            this.playerMoveTween.stop();\r\n            this.playerMoveTween = null;\r\n        }\r\n\r\n        if (this.playerDieSprite) {\r\n            this.playerDieSprite.destroy();\r\n            this.playerDieSprite = null;\r\n        }\r\n\r\n        // Recreate player sprite if needed\r\n        if (!this.playerSprite) {\r\n            this.playerSprite = this.scene.add.sprite(\r\n                position.x * this.cellSize + this.cellSize / 2,\r\n                position.y * this.cellSize + this.cellSize / 2,\r\n                'player_stand'\r\n            );\r\n            this.playerSprite.setDepth(10);\r\n        } else {\r\n            this.playerSprite.setPosition(\r\n                position.x * this.cellSize + this.cellSize / 2,\r\n                position.y * this.cellSize + this.cellSize / 2\r\n            );\r\n            this.playerSprite.setVisible(true);\r\n            this.playerSprite.setTexture('player_stand');\r\n        }\r\n\r\n        this.adjustScaleAndRotation();\r\n    }\r\n\r\n    /**\r\n     * Obtiene la posici√≥n actual del jugador\r\n     */\r\n    getPosition(): Position {\r\n        return { ...this.playerPosition };\r\n    }\r\n\r\n    /**\r\n     * Obtiene la direcci√≥n actual de movimiento\r\n     */\r\n    getMoveDirection(): Direction {\r\n        return { ...this.moveDirection };\r\n    }\r\n\r\n    /**\r\n     * Verifica si el jugador est√° en movimiento\r\n     */\r\n    getIsMoving(): boolean {\r\n        return this.isMoving;\r\n    }\r\n\r\n    /**\r\n     * Obtiene el sprite del jugador\r\n     */\r\n    getSprite(): Phaser.GameObjects.Sprite | null {\r\n        return this.playerSprite;\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.stopMovement();\r\n        if (this.playerSprite) this.playerSprite.destroy();\r\n        if (this.playerDieSprite) this.playerDieSprite.destroy();\r\n        if (this.coinParticles) this.coinParticles.destroy();\r\n        if (this.trailParticles) this.trailParticles.destroy();\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale, generateFreePosition } from '../utils/Utils';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { Position, Direction, Enemy } from '../types/game.types';\r\n\r\n/**\r\n * Gestor de enemigos regulares con movimiento aleatorio\r\n * Soporta colisi√≥n entre enemigos\r\n */\r\nexport class EnemyManager {\r\n    private scene: Phaser.Scene;\r\n    private collision: CollisionSystem;\r\n    private enemies: Enemy[] = [];\r\n    private cellSize: number;\r\n\r\n    constructor(scene: Phaser.Scene, collision: CollisionSystem, cellSize: number) {\r\n        this.scene = scene;\r\n        this.collision = collision;\r\n        this.cellSize = cellSize;\r\n    }\r\n\r\n    /**\r\n     * Inicializa los enemigos seg√∫n el nivel\r\n     * - Primer enemigo aparece en nivel 5\r\n     * - Segundo enemigo aparece cada 7 niveles (5, 12, 19, 26...)\r\n     */\r\n    init(level: number, excludePositions: Position[]): void {\r\n        this.reset();\r\n\r\n        // Los enemigos solo aparecen desde el nivel configurado\r\n        if (level < CONFIG.ENEMIES.FIRST_SPAWN_LEVEL) return;\r\n\r\n        // Calcular cantidad de enemigos: 1 base + 1 adicional cada SECOND_ENEMY_INTERVAL niveles\r\n        let enemyCount = 1;\r\n        const secondEnemyLevel = CONFIG.ENEMIES.FIRST_SPAWN_LEVEL + CONFIG.ENEMIES.SECOND_ENEMY_INTERVAL;\r\n        if (level >= secondEnemyLevel) {\r\n            enemyCount = 1 + Math.floor((level - CONFIG.ENEMIES.FIRST_SPAWN_LEVEL) / CONFIG.ENEMIES.SECOND_ENEMY_INTERVAL);\r\n        }\r\n        // Cap m√°ximo de enemigos\r\n        enemyCount = Math.min(enemyCount, CONFIG.ENEMIES.MAX_COUNT);\r\n\r\n        const boardSize = this.collision.getBoardSize();\r\n\r\n        for (let i = 0; i < enemyCount; i++) {\r\n            const allExcluded = [...excludePositions, ...this.enemies.map(e => ({ x: e.x, y: e.y }))];\r\n            const position = generateFreePosition(allExcluded, boardSize);\r\n\r\n            if (!position) continue;\r\n\r\n            const enemy: Enemy = {\r\n                x: position.x,\r\n                y: position.y,\r\n                direction: this.getRandomDirection(),\r\n                moving: false,\r\n                sprite: null\r\n            };\r\n\r\n            enemy.sprite = this.scene.add.sprite(\r\n                enemy.x * this.cellSize + this.cellSize / 2,\r\n                enemy.y * this.cellSize + this.cellSize / 2,\r\n                'enemy'\r\n            );\r\n\r\n            const enemyScale = calculateSpriteScale('enemy', this.cellSize, this.scene);\r\n            enemy.sprite.setScale(enemyScale);\r\n            enemy.sprite.setFlipX(enemy.direction.dx === -1);\r\n\r\n            this.enemies.push(enemy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza el movimiento de todos los enemigos\r\n     * Incluye colisi√≥n entre enemigos\r\n     */\r\n    update(): void {\r\n        this.enemies.forEach((enemy, index) => {\r\n            if (!enemy?.sprite) return;\r\n\r\n            if (!enemy.moving) {\r\n                enemy.moving = true;\r\n                const nextX = enemy.x + enemy.direction.dx;\r\n                const nextY = enemy.y + enemy.direction.dy;\r\n\r\n                // Check wall collision\r\n                const wallCollision = this.collision.isCollision(nextX, nextY);\r\n\r\n                // Check collision with other enemies\r\n                const enemyCollision = this.checkEnemyAtPosition(nextX, nextY, index);\r\n\r\n                if (wallCollision || enemyCollision) {\r\n                    enemy.direction = this.getRandomDirection();\r\n                    enemy.moving = false;\r\n                    enemy.sprite.setFlipX(enemy.direction.dx === -1);\r\n                } else {\r\n                    this.scene.tweens.add({\r\n                        targets: enemy.sprite,\r\n                        x: nextX * this.cellSize + this.cellSize / 2,\r\n                        y: nextY * this.cellSize + this.cellSize / 2,\r\n                        duration: CONFIG.ENEMIES.MOVE_TWEEN_DURATION_MS,\r\n                        onComplete: () => {\r\n                            enemy.x = nextX;\r\n                            enemy.y = nextY;\r\n                            enemy.moving = false;\r\n\r\n                            // Emit collision check event\r\n                            this.scene.events.emit('enemy:moved', { x: enemy.x, y: enemy.y });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si hay otro enemigo en una posici√≥n (excluyendo el actual)\r\n     */\r\n    private checkEnemyAtPosition(x: number, y: number, excludeIndex: number): boolean {\r\n        return this.enemies.some((e, i) => {\r\n            if (i === excludeIndex) return false;\r\n            return Math.round(e.x) === x && Math.round(e.y) === y;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si el jugador colisiona con alg√∫n enemigo\r\n     */\r\n    checkCollision(playerX: number, playerY: number): boolean {\r\n        return this.enemies.some(\r\n            e => Math.round(e.x) === playerX && Math.round(e.y) === playerY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Obtiene una direcci√≥n aleatoria\r\n     */\r\n    private getRandomDirection(): Direction {\r\n        const directions: Direction[] = [\r\n            { dx: 0, dy: -1 },\r\n            { dx: 1, dy: 0 },\r\n            { dx: 0, dy: 1 },\r\n            { dx: -1, dy: 0 }\r\n        ];\r\n        return directions[Phaser.Math.Between(0, directions.length - 1)];\r\n    }\r\n\r\n    /**\r\n     * Obtiene los enemigos actuales\r\n     */\r\n    getEnemies(): Enemy[] {\r\n        return this.enemies;\r\n    }\r\n\r\n    /**\r\n     * Actualiza los sprites de enemigos (para flip direction)\r\n     */\r\n    updateSprites(): void {\r\n        this.enemies.forEach(enemy => {\r\n            if (enemy.sprite) {\r\n                if (enemy.direction.dx === -1) {\r\n                    enemy.sprite.setFlipX(true);\r\n                } else if (enemy.direction.dx === 1) {\r\n                    enemy.sprite.setFlipX(false);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resetea todos los enemigos\r\n     */\r\n    reset(): void {\r\n        this.enemies.forEach(enemy => {\r\n            if (enemy?.sprite) {\r\n                enemy.sprite.destroy();\r\n            }\r\n        });\r\n        this.enemies = [];\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.reset();\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale } from '../utils/Utils';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { Position, Obstacle, Spider, SpiderState } from '../types/game.types';\r\n\r\n/**\r\n * Gestor de ara√±as con patrullaje entre dos puntos\r\n */\r\nexport class SpiderManager {\r\n    private scene: Phaser.Scene;\r\n    private collision: CollisionSystem;\r\n    private spiders: Spider[] = [];\r\n    private cellSize: number;\r\n    private boardSize: number;\r\n    private obstacles: Obstacle[] = [];\r\n\r\n    constructor(scene: Phaser.Scene, collision: CollisionSystem, cellSize: number, boardSize: number) {\r\n        this.scene = scene;\r\n        this.collision = collision;\r\n        this.cellSize = cellSize;\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Genera ara√±as seg√∫n el nivel\r\n     */\r\n    generate(level: number, obstacles: Obstacle[], exitPosition: Position): void {\r\n        this.reset();\r\n        this.obstacles = obstacles;\r\n\r\n        if (!this.boardSize) return;\r\n\r\n        let spiderCount = 0;\r\n        // Spiders only appear from configured level\r\n        if (level < CONFIG.SPIDER.FIRST_SPAWN_LEVEL) {\r\n            spiderCount = 0;\r\n        } else if (level < CONFIG.SPIDER.SECOND_SPAWN_LEVEL) {\r\n            spiderCount = 1;\r\n        } else if (level < CONFIG.SPIDER.THIRD_SPAWN_LEVEL) {\r\n            spiderCount = 2;\r\n        } else {\r\n            spiderCount = 3;\r\n        }\r\n\r\n        if (spiderCount === 0) return;\r\n\r\n        for (let i = 0; i < spiderCount; i++) {\r\n            let attempts = 0;\r\n            let spiderAdded = false;\r\n\r\n            while (!spiderAdded && attempts < 50) {\r\n                attempts++;\r\n\r\n                const pointA = {\r\n                    x: Phaser.Math.Between(0, this.boardSize - 1),\r\n                    y: Phaser.Math.Between(0, this.boardSize - 1)\r\n                };\r\n\r\n                if (!this.isValidPoint(pointA, exitPosition)) continue;\r\n\r\n                const axis = Phaser.Math.Between(0, 1);\r\n                const pointB = { x: pointA.x, y: pointA.y };\r\n\r\n                if (axis === 0) {\r\n                    pointB.x = Phaser.Math.Between(0, this.boardSize - 1);\r\n                } else {\r\n                    pointB.y = Phaser.Math.Between(0, this.boardSize - 1);\r\n                }\r\n\r\n                const dist = Math.abs((pointB.x - pointA.x) + (pointB.y - pointA.y));\r\n                if (dist < CONFIG.SPIDER.MIN_PATROL_DISTANCE) continue;\r\n                if (!this.isValidPoint(pointB, exitPosition)) continue;\r\n                // Use centralized isPathClear from CollisionSystem\r\n                if (!this.collision.isPathClear(pointA, pointB, this.obstacles)) continue;\r\n\r\n                const spider: Spider = {\r\n                    state: 'WAITING' as SpiderState,\r\n                    pointA: { ...pointA },\r\n                    pointB: { ...pointB },\r\n                    currentTarget: { ...pointB },\r\n                    x: pointA.x,\r\n                    y: pointA.y,\r\n                    waitStartTime: this.scene.time.now,\r\n                    sprite: null\r\n                };\r\n\r\n                spider.sprite = this.scene.add.sprite(\r\n                    spider.x * this.cellSize + this.cellSize / 2,\r\n                    spider.y * this.cellSize + this.cellSize / 2,\r\n                    'spider'\r\n                );\r\n\r\n                const spiderScale = calculateSpriteScale('spider', this.cellSize, this.scene);\r\n                spider.sprite.setScale(spiderScale);\r\n\r\n                this.spiders.push(spider);\r\n                spiderAdded = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza el estado y movimiento de las ara√±as\r\n     */\r\n    update(time: number, playerPosition: Position): boolean {\r\n        let playerHit = false;\r\n\r\n        this.spiders.forEach(spider => {\r\n            if (!spider.sprite) return;\r\n\r\n            // Collision check\r\n            if (Math.round(spider.x) === playerPosition.x &&\r\n                Math.round(spider.y) === playerPosition.y) {\r\n                playerHit = true;\r\n            }\r\n\r\n            // State machine\r\n            if (spider.state === 'WAITING') {\r\n                if (time - spider.waitStartTime > CONFIG.SPIDER.WAIT_DURATION_MS) {\r\n                    spider.state = 'MOVING';\r\n                }\r\n            } else if (spider.state === 'MOVING') {\r\n                const dx = spider.currentTarget.x - spider.x;\r\n                const dy = spider.currentTarget.y - spider.y;\r\n                const speed = CONFIG.SPIDER.MOVE_SPEED;\r\n\r\n                if (Math.abs(dx) < speed && Math.abs(dy) < speed) {\r\n                    // Arrived at target\r\n                    spider.x = spider.currentTarget.x;\r\n                    spider.y = spider.currentTarget.y;\r\n                    spider.sprite.setPosition(\r\n                        spider.x * this.cellSize + this.cellSize / 2,\r\n                        spider.y * this.cellSize + this.cellSize / 2\r\n                    );\r\n\r\n                    spider.state = 'WAITING';\r\n                    spider.waitStartTime = time;\r\n\r\n                    // Toggle target\r\n                    if (spider.currentTarget.x === spider.pointA.x &&\r\n                        spider.currentTarget.y === spider.pointA.y) {\r\n                        spider.currentTarget = { ...spider.pointB };\r\n                    } else {\r\n                        spider.currentTarget = { ...spider.pointA };\r\n                    }\r\n                } else {\r\n                    // Move towards target\r\n                    spider.x += Math.sign(dx) * speed;\r\n                    spider.y += Math.sign(dy) * speed;\r\n\r\n                    spider.sprite.setPosition(\r\n                        spider.x * this.cellSize + this.cellSize / 2,\r\n                        spider.y * this.cellSize + this.cellSize / 2\r\n                    );\r\n                }\r\n            }\r\n        });\r\n\r\n        return playerHit;\r\n    }\r\n\r\n    /**\r\n     * Verifica si un punto es v√°lido para la ara√±a\r\n     */\r\n    private isValidPoint(p: Position, exitPosition: Position): boolean {\r\n        if (p.x < 0 || p.x >= this.boardSize || p.y < 0 || p.y >= this.boardSize) {\r\n            return false;\r\n        }\r\n        if (p.x === 0 && p.y === 0) return false; // Player start\r\n        if (p.x === exitPosition.x && p.y === exitPosition.y) return false;\r\n        if (this.obstacles.some(o => o.x === p.x && o.y === p.y)) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Verifica colisi√≥n del jugador con ara√±as\r\n     */\r\n    checkCollision(playerX: number, playerY: number): boolean {\r\n        return this.spiders.some(\r\n            s => Math.round(s.x) === playerX && Math.round(s.y) === playerY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Obtiene las ara√±as actuales\r\n     */\r\n    getSpiders(): Spider[] {\r\n        return this.spiders;\r\n    }\r\n\r\n    /**\r\n     * Resetea todas las ara√±as\r\n     */\r\n    reset(): void {\r\n        this.spiders.forEach(spider => {\r\n            if (spider.sprite) {\r\n                spider.sprite.destroy();\r\n            }\r\n        });\r\n        this.spiders = [];\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.reset();\r\n    }\r\n}\r\n","import type { EventListenerEntry } from '../types/game.types';\r\n\r\n/**\r\n * Callbacks para eventos de UI\r\n */\r\nexport interface UICallbacks {\r\n    onMusicToggle: () => void;\r\n    onMusicStop: () => void;\r\n    onVolumeChange: (volume: number) => void;\r\n    onNextMusic: () => void;\r\n    onMenu: () => void;\r\n    onContinue: () => void;\r\n    onRestart: () => void;\r\n}\r\n\r\n/**\r\n * Gestor de interfaz de usuario (elementos DOM)\r\n */\r\nexport class UIManager {\r\n    private eventListenerCleanup: EventListenerEntry[] = [];\r\n    private toggleMusicButton: HTMLElement | null = null;\r\n\r\n    constructor() { }\r\n\r\n    /**\r\n     * Actualiza el marcador de puntuaci√≥n\r\n     */\r\n    updateScore(score: number): void {\r\n        const safeScore = (typeof score === 'number' && !isNaN(score)) ? score : 0;\r\n        const scoreElement = document.getElementById('score');\r\n        if (scoreElement) {\r\n            scoreElement.textContent = 'Puntos: ' + safeScore;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza el indicador de nivel\r\n     */\r\n    updateLevel(level: number): void {\r\n        const safeLevel = (typeof level === 'number' && !isNaN(level)) ? level : 1;\r\n        const levelElement = document.getElementById('level');\r\n        if (levelElement) {\r\n            levelElement.textContent = 'Nivel: ' + safeLevel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza los contadores de power-ups\r\n     */\r\n    updatePowerUps(shields: number, continues: number): void {\r\n        const shieldsElement = document.getElementById('shields');\r\n        const continuesElement = document.getElementById('continues');\r\n\r\n        if (shieldsElement) {\r\n            shieldsElement.textContent = 'S: ' + shields;\r\n            shieldsElement.style.opacity = shields > 0 ? '1' : '0.4';\r\n        }\r\n        if (continuesElement) {\r\n            continuesElement.textContent = 'C: ' + continues;\r\n            continuesElement.style.opacity = continues > 0 ? '1' : '0.4';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza tanto puntuaci√≥n como nivel\r\n     */\r\n    updateScoreAndLevel(score: number, level: number): void {\r\n        this.updateScore(score);\r\n        this.updateLevel(level);\r\n    }\r\n\r\n    /**\r\n     * Actualiza toda la UI (score, level, power-ups)\r\n     */\r\n    updateAll(score: number, level: number, shields: number, continues: number): void {\r\n        this.updateScore(score);\r\n        this.updateLevel(level);\r\n        this.updatePowerUps(shields, continues);\r\n    }\r\n\r\n    /**\r\n     * Actualiza el estado visual del bot√≥n de m√∫sica\r\n     */\r\n    updateMusicButtonState(isPlaying: boolean): void {\r\n        if (this.toggleMusicButton) {\r\n            if (isPlaying) {\r\n                this.toggleMusicButton.textContent = '‚ùö‚ùö';\r\n                this.toggleMusicButton.classList.add('playing');\r\n            } else {\r\n                this.toggleMusicButton.textContent = '‚ñ∂';\r\n                this.toggleMusicButton.classList.remove('playing');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configura los event listeners para los controles de UI\r\n     */\r\n    setupEventListeners(callbacks: UICallbacks): void {\r\n        // Cleanup old listeners\r\n        this.cleanup();\r\n\r\n        this.toggleMusicButton = document.getElementById('toggle-music');\r\n        const stopMusicButton = document.getElementById('stop-music');\r\n        const volumeSlider = document.getElementById('volume-slider') as HTMLInputElement;\r\n        const nextButton = document.getElementById('next-music');\r\n        const menuButton = document.getElementById('menu-button');\r\n        const continueButton = document.getElementById('continue-button');\r\n        const restartButton = document.getElementById('restart-button');\r\n\r\n        const addListener = (\r\n            element: HTMLElement | null,\r\n            event: string,\r\n            handler: EventListener\r\n        ): void => {\r\n            if (element) {\r\n                element.addEventListener(event, handler);\r\n                this.eventListenerCleanup.push({ element, event, handler });\r\n            }\r\n        };\r\n\r\n        addListener(this.toggleMusicButton, 'click', () => {\r\n            callbacks.onMusicToggle();\r\n        });\r\n\r\n        addListener(stopMusicButton, 'click', () => {\r\n            callbacks.onMusicStop();\r\n        });\r\n\r\n        addListener(volumeSlider, 'input', (e: Event) => {\r\n            const target = e.target as HTMLInputElement;\r\n            callbacks.onVolumeChange(parseFloat(target.value));\r\n        });\r\n\r\n        addListener(nextButton, 'click', () => {\r\n            callbacks.onNextMusic();\r\n        });\r\n\r\n        addListener(menuButton, 'click', () => {\r\n            callbacks.onMenu();\r\n        });\r\n\r\n        addListener(continueButton, 'click', () => {\r\n            callbacks.onContinue();\r\n        });\r\n\r\n        addListener(restartButton, 'click', () => {\r\n            callbacks.onRestart();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Limpia todos los event listeners\r\n     */\r\n    cleanup(): void {\r\n        this.eventListenerCleanup.forEach(({ element, event, handler }) => {\r\n            if (element) {\r\n                element.removeEventListener(event, handler);\r\n            }\r\n        });\r\n        this.eventListenerCleanup = [];\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.cleanup();\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { ScoreManager } from './ScoreManager';\r\n\r\n/**\r\n * Gestor del estado del juego (game over, score, level, power-ups)\r\n */\r\nexport class GameStateManager {\r\n    private scene: Phaser.Scene;\r\n    private _gameOver: boolean = false;\r\n    private _level: number = 1;\r\n    private _score: number = 0;\r\n    private _initialCoinCount: number = 0;\r\n\r\n    // Power-ups\r\n    private _shieldCount: number = 0;\r\n    private _continueCount: number = 0;\r\n\r\n    // Game Over UI\r\n    private gameOverText: Phaser.GameObjects.Text | null = null;\r\n    private restartText: Phaser.GameObjects.Text | null = null;\r\n    private continueText: Phaser.GameObjects.Text | null = null;\r\n    private newRecordText: Phaser.GameObjects.Text | null = null;\r\n    private menuText: Phaser.GameObjects.Text | null = null;\r\n\r\n    constructor(scene: Phaser.Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Crea los textos de UI del game over\r\n     */\r\n    createGameOverUI(): void {\r\n        this.gameOverText = this.scene.add.text(\r\n            CONFIG.GAME_WIDTH / 2,\r\n            CONFIG.GAME_HEIGHT / 2,\r\n            'GAME OVER',\r\n            {\r\n                fontSize: CONFIG.UI.GAME_OVER_FONT_SIZE,\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#ff0000',\r\n                stroke: '#ffffff',\r\n                strokeThickness: 4\r\n            }\r\n        );\r\n        this.gameOverText.setOrigin(0.5);\r\n        this.gameOverText.setDepth(100);\r\n        this.gameOverText.setVisible(false);\r\n\r\n        this.restartText = this.scene.add.text(\r\n            CONFIG.GAME_WIDTH / 2,\r\n            CONFIG.GAME_HEIGHT / 2 + CONFIG.UI.RESTART_OFFSET_Y,\r\n            'PRESS R TO RESTART',\r\n            {\r\n                fontSize: CONFIG.UI.RESTART_FONT_SIZE,\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#ffff00',\r\n                align: 'center'\r\n            }\r\n        );\r\n        this.restartText.setOrigin(0.5);\r\n        this.restartText.setDepth(100);\r\n        this.restartText.setVisible(false);\r\n    }\r\n\r\n    /**\r\n     * Muestra la pantalla de game over\r\n     */\r\n    showGameOver(): void {\r\n        this._gameOver = true;\r\n        const isNewRecord = ScoreManager.setHighScore(this._score);\r\n\r\n        this.gameOverText?.setVisible(true);\r\n        this.restartText?.setVisible(true);\r\n\r\n        // Show continue option if player has continues\r\n        if (this._continueCount > 0) {\r\n            if (!this.continueText) {\r\n                this.continueText = this.scene.add.text(\r\n                    CONFIG.GAME_WIDTH / 2,\r\n                    CONFIG.GAME_HEIGHT / 2 + CONFIG.UI.RESTART_OFFSET_Y + 25,\r\n                    '',\r\n                    {\r\n                        fontSize: '14px',\r\n                        fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                        color: '#00ff00'\r\n                    }\r\n                );\r\n                this.continueText.setOrigin(0.5);\r\n                this.continueText.setDepth(100);\r\n            }\r\n            this.continueText.setText(`C PARA CONTINUAR (${this._continueCount}‚ù§)`);\r\n            this.continueText.setVisible(true);\r\n        } else {\r\n            this.continueText?.setVisible(false);\r\n        }\r\n\r\n        if (isNewRecord && this._score > 0) {\r\n            if (!this.newRecordText) {\r\n                this.newRecordText = this.scene.add.text(\r\n                    CONFIG.GAME_WIDTH / 2,\r\n                    CONFIG.GAME_HEIGHT / 2 - 60,\r\n                    '¬°NUEVO R√âCORD!',\r\n                    {\r\n                        fontSize: '20px',\r\n                        fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                        color: '#ffff00',\r\n                        stroke: '#ff6600',\r\n                        strokeThickness: 3\r\n                    }\r\n                );\r\n                this.newRecordText.setOrigin(0.5);\r\n                this.newRecordText.setDepth(100);\r\n            }\r\n            this.newRecordText.setVisible(true);\r\n\r\n            this.scene.tweens.add({\r\n                targets: this.newRecordText,\r\n                scaleX: 1.2,\r\n                scaleY: 1.2,\r\n                duration: 400,\r\n                yoyo: true,\r\n                repeat: -1\r\n            });\r\n        }\r\n\r\n        // Adjust menu text position based on whether continue is shown\r\n        const menuOffsetY = this._continueCount > 0\r\n            ? CONFIG.UI.RESTART_OFFSET_Y + 55\r\n            : CONFIG.UI.RESTART_OFFSET_Y + 30;\r\n\r\n        if (!this.menuText) {\r\n            this.menuText = this.scene.add.text(\r\n                CONFIG.GAME_WIDTH / 2,\r\n                CONFIG.GAME_HEIGHT / 2 + menuOffsetY,\r\n                'PRESIONA M PARA MEN√ö',\r\n                {\r\n                    fontSize: '14px',\r\n                    fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                    color: '#888888'\r\n                }\r\n            );\r\n            this.menuText.setOrigin(0.5);\r\n            this.menuText.setDepth(100);\r\n        } else {\r\n            this.menuText.setY(CONFIG.GAME_HEIGHT / 2 + menuOffsetY);\r\n        }\r\n        this.menuText.setVisible(true);\r\n    }\r\n\r\n    /**\r\n     * Oculta la UI de game over\r\n     */\r\n    hideGameOverUI(): void {\r\n        this.gameOverText?.setVisible(false);\r\n        this.restartText?.setVisible(false);\r\n        this.continueText?.setVisible(false);\r\n        this.newRecordText?.setVisible(false);\r\n        this.menuText?.setVisible(false);\r\n    }\r\n\r\n    /**\r\n     * A√±ade puntos al score\r\n     */\r\n    addScore(points: number): void {\r\n        this._score += points;\r\n    }\r\n\r\n    /**\r\n     * Avanza al siguiente nivel\r\n     */\r\n    nextLevel(): void {\r\n        this._score += 100;\r\n        this._level += 1;\r\n    }\r\n\r\n    // ========== POWER-UPS ==========\r\n\r\n    /**\r\n     * A√±ade un shield\r\n     */\r\n    addShield(): void {\r\n        this._shieldCount++;\r\n    }\r\n\r\n    /**\r\n     * Consume un shield si est√° disponible\r\n     * @returns true si se consumi√≥, false si no hab√≠a\r\n     */\r\n    useShield(): boolean {\r\n        if (this._shieldCount > 0) {\r\n            this._shieldCount--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * A√±ade un continue\r\n     */\r\n    addContinue(): void {\r\n        this._continueCount++;\r\n    }\r\n\r\n    /**\r\n     * Consume un continue si est√° disponible\r\n     * @returns true si se consumi√≥, false si no hab√≠a\r\n     */\r\n    useContinue(): boolean {\r\n        if (this._continueCount > 0) {\r\n            this._continueCount--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Verifica si tiene shield disponible\r\n     */\r\n    hasShield(): boolean {\r\n        return this._shieldCount > 0;\r\n    }\r\n\r\n    /**\r\n     * Verifica si tiene continue disponible\r\n     */\r\n    hasContinue(): boolean {\r\n        return this._continueCount > 0;\r\n    }\r\n\r\n    // ========== RESET ==========\r\n\r\n    /**\r\n     * Resetea el estado del juego\r\n     */\r\n    reset(fullReset: boolean): void {\r\n        if (fullReset) {\r\n            this._level = 1;\r\n            this._score = 0;\r\n            this._shieldCount = 0;\r\n            this._continueCount = 0;\r\n        }\r\n        this._gameOver = false;\r\n        this.hideGameOverUI();\r\n    }\r\n\r\n    /**\r\n     * Aplica valores de dev mode\r\n     */\r\n    applyDevMode(level: number, shields: number, continues: number, score: number): void {\r\n        this._level = level;\r\n        this._shieldCount = shields;\r\n        this._continueCount = continues;\r\n        this._score = score;\r\n    }\r\n\r\n    /**\r\n     * Retorna al men√∫ principal\r\n     */\r\n    returnToMenu(): void {\r\n        this.scene.cameras.main.fadeOut(300, 0, 0, 0);\r\n        this.scene.time.delayedCall(300, () => {\r\n            this.scene.scene.start('MenuScene');\r\n        });\r\n    }\r\n\r\n    // ========== GETTERS/SETTERS ==========\r\n\r\n    get isGameOver(): boolean {\r\n        return this._gameOver;\r\n    }\r\n\r\n    set isGameOver(value: boolean) {\r\n        this._gameOver = value;\r\n    }\r\n\r\n    get level(): number {\r\n        return this._level;\r\n    }\r\n\r\n    get score(): number {\r\n        return this._score;\r\n    }\r\n\r\n    get shieldCount(): number {\r\n        return this._shieldCount;\r\n    }\r\n\r\n    get continueCount(): number {\r\n        return this._continueCount;\r\n    }\r\n\r\n    get initialCoinCount(): number {\r\n        return this._initialCoinCount;\r\n    }\r\n\r\n    set initialCoinCount(value: number) {\r\n        this._initialCoinCount = value;\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        if (this.gameOverText) this.gameOverText.destroy();\r\n        if (this.restartText) this.restartText.destroy();\r\n        if (this.continueText) this.continueText.destroy();\r\n        if (this.newRecordText) this.newRecordText.destroy();\r\n        if (this.menuText) this.menuText.destroy();\r\n    }\r\n}\r\n","import type { Position, Obstacle } from '../types/game.types';\r\n\r\n/**\r\n * Sistema de colisiones optimizado con mapa pre-calculado\r\n * Proporciona queries r√°pidas O(1) para detecci√≥n de colisiones\r\n */\r\nexport class CollisionSystem {\r\n    private boardSize: number;\r\n    private collisionMap: boolean[][] | null = null;\r\n\r\n    constructor(boardSize: number) {\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Construye el mapa de colisiones basado en obst√°culos\r\n     */\r\n    build(obstacles: Obstacle[]): void {\r\n        if (!this.boardSize || this.boardSize < 1) {\r\n            console.error('CollisionSystem.build: Invalid boardSize:', this.boardSize);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            this.collisionMap = Array.from(\r\n                { length: this.boardSize },\r\n                () => Array(this.boardSize).fill(false)\r\n            );\r\n\r\n            obstacles.forEach(obstacle => {\r\n                if (this.isWithinBounds(obstacle.x, obstacle.y)) {\r\n                    this.collisionMap![obstacle.y][obstacle.x] = true;\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.error('Error building collision map:', error);\r\n            this.collisionMap = Array.from(\r\n                { length: this.boardSize },\r\n                () => Array(this.boardSize).fill(false)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifica si una posici√≥n tiene colisi√≥n (obst√°culo o fuera de l√≠mites)\r\n     */\r\n    isCollision(x: number, y: number): boolean {\r\n        if (this.isOutOfBounds(x, y)) {\r\n            return true;\r\n        }\r\n        return this.collisionMap?.[y]?.[x] ?? false;\r\n    }\r\n\r\n    /**\r\n     * Verifica si una posici√≥n contiene una trampa\r\n     */\r\n    isTrap(x: number, y: number, traps: Position[]): boolean {\r\n        if (this.isOutOfBounds(x, y)) {\r\n            return false;\r\n        }\r\n        return traps.some(trap => trap.x === x && trap.y === y);\r\n    }\r\n\r\n    /**\r\n     * Verifica si las coordenadas est√°n fuera del tablero\r\n     */\r\n    isOutOfBounds(x: number, y: number): boolean {\r\n        return x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize;\r\n    }\r\n\r\n    /**\r\n     * Verifica si las coordenadas est√°n dentro del tablero\r\n     */\r\n    isWithinBounds(x: number, y: number): boolean {\r\n        return x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize;\r\n    }\r\n\r\n    /**\r\n     * Calcula el movimiento hasta encontrar un obst√°culo\r\n     * Devuelve la posici√≥n final y la distancia recorrida\r\n     */\r\n    calculateMoveUntilObstacle(\r\n        startX: number,\r\n        startY: number,\r\n        dx: number,\r\n        dy: number\r\n    ): { x: number; y: number; distance: number } {\r\n        let currentX = startX;\r\n        let currentY = startY;\r\n        let distance = 0;\r\n\r\n        while (true) {\r\n            const nextX = currentX + dx;\r\n            const nextY = currentY + dy;\r\n\r\n            if (this.isCollision(nextX, nextY)) {\r\n                break;\r\n            }\r\n\r\n            currentX = nextX;\r\n            currentY = nextY;\r\n            distance++;\r\n        }\r\n\r\n        return { x: currentX, y: currentY, distance };\r\n    }\r\n\r\n    /**\r\n     * Verifica si el camino entre dos puntos est√° libre\r\n     */\r\n    isPathClear(start: Position, end: Position, obstacles: Obstacle[]): boolean {\r\n        const dx = Math.sign(end.x - start.x);\r\n        const dy = Math.sign(end.y - start.y);\r\n\r\n        let currX = start.x;\r\n        let currY = start.y;\r\n\r\n        while (currX !== end.x || currY !== end.y) {\r\n            currX += dx;\r\n            currY += dy;\r\n\r\n            if (obstacles.some(o => o.x === currX && o.y === currY)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Actualiza el tama√±o del tablero\r\n     */\r\n    setBoardSize(size: number): void {\r\n        this.boardSize = size;\r\n        this.collisionMap = null;\r\n    }\r\n\r\n    /**\r\n     * Obtiene el tama√±o del tablero\r\n     */\r\n    getBoardSize(): number {\r\n        return this.boardSize;\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { generateFreePosition } from '../utils/Utils';\r\nimport type { Position, Obstacle } from '../types/game.types';\r\n\r\n/**\r\n * Datos generados del laberinto\r\n */\r\nexport interface MazeData {\r\n    coins: Position[];\r\n    obstacles: Obstacle[];\r\n    traps: Position[];\r\n    exitPosition: Position;\r\n}\r\n\r\n/**\r\n * Generador procedural de laberintos con validaci√≥n de solvability\r\n */\r\nexport class MazeGenerator {\r\n    private boardSize: number;\r\n\r\n    constructor(boardSize: number) {\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Genera un laberinto completo v√°lido (garantiza que sea solucionable)\r\n     */\r\n    generate(exitPosition: Position): MazeData {\r\n        const playerStart: Position = { x: 0, y: 0 };\r\n\r\n        let attempts = 0;\r\n        const maxAttempts = CONFIG.MAZE_GENERATION.MAX_ATTEMPTS;\r\n        let mazeData: MazeData;\r\n\r\n        do {\r\n            attempts++;\r\n            mazeData = this.generateAttempt(playerStart, exitPosition);\r\n        } while (!this.isSolvable(playerStart, exitPosition, mazeData) && attempts < maxAttempts);\r\n\r\n        if (attempts >= maxAttempts) {\r\n            console.warn('MazeGenerator: Max attempts reached, generating simple maze');\r\n            return this.generateSimpleMaze(exitPosition);\r\n        }\r\n\r\n        return mazeData;\r\n    }\r\n\r\n    /**\r\n     * Genera una posici√≥n aleatoria para la salida en el borde derecho o inferior\r\n     */\r\n    generateRandomExit(): Position {\r\n        const side = Math.floor(Math.random() * 2);\r\n        if (side === 0) {\r\n            return { x: this.boardSize - 1, y: Math.floor(Math.random() * this.boardSize) };\r\n        } else {\r\n            return { x: Math.floor(Math.random() * this.boardSize), y: this.boardSize - 1 };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Genera un save item en una posici√≥n v√°lida\r\n     */\r\n    generateSaveItem(excludePositions: Position[]): Position | null {\r\n        return generateFreePosition(excludePositions, this.boardSize);\r\n    }\r\n\r\n    /**\r\n     * Un intento de generaci√≥n de laberinto\r\n     */\r\n    private generateAttempt(playerStart: Position, exitPosition: Position): MazeData {\r\n        const coins: Position[] = [];\r\n        const obstacles: Obstacle[] = [];\r\n        const traps: Position[] = [];\r\n\r\n        for (let y = 0; y < this.boardSize; y++) {\r\n            for (let x = 0; x < this.boardSize; x++) {\r\n                // Skip player start and exit\r\n                if ((x === playerStart.x && y === playerStart.y) ||\r\n                    (x === exitPosition.x && y === exitPosition.y)) {\r\n                    continue;\r\n                }\r\n\r\n                if (Math.random() < CONFIG.MAZE_GENERATION.OBSTACLE_PROBABILITY &&\r\n                    this.hasEnoughSpace(x, y, obstacles, traps)) {\r\n                    const obstacleTypes: Array<'brick' | 'rock' | 'tree'> = ['brick', 'rock', 'tree'];\r\n                    const randomType = obstacleTypes[Phaser.Math.Between(0, obstacleTypes.length - 1)];\r\n                    obstacles.push({ x, y, type: randomType });\r\n                } else if (Math.random() < CONFIG.MAZE_GENERATION.COIN_PROBABILITY) {\r\n                    coins.push({ x, y });\r\n                } else if (Math.random() < CONFIG.MAZE_GENERATION.TRAP_PROBABILITY &&\r\n                    this.hasEnoughSpace(x, y, obstacles, traps)) {\r\n                    traps.push({ x, y });\r\n                }\r\n            }\r\n        }\r\n\r\n        return { coins, obstacles, traps, exitPosition };\r\n    }\r\n\r\n    /**\r\n     * Verifica que hay suficiente espacio alrededor de una posici√≥n\r\n     */\r\n    private hasEnoughSpace(x: number, y: number, obstacles: Obstacle[], traps: Position[]): boolean {\r\n        const directions = [\r\n            { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 },\r\n            { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }\r\n        ];\r\n\r\n        let freeSpaces = 0;\r\n        for (const dir of directions) {\r\n            const nx = x + dir.x;\r\n            const ny = y + dir.y;\r\n            if (\r\n                nx >= 0 && nx < this.boardSize &&\r\n                ny >= 0 && ny < this.boardSize &&\r\n                !obstacles.some(obs => obs.x === nx && obs.y === ny) &&\r\n                !traps.some(trap => trap.x === nx && trap.y === ny)\r\n            ) {\r\n                freeSpaces++;\r\n            }\r\n        }\r\n\r\n        return freeSpaces >= CONFIG.MAZE_GENERATION.MIN_FREE_SPACES;\r\n    }\r\n\r\n    /**\r\n     * Verifica que el laberinto es solucionable usando BFS\r\n     */\r\n    private isSolvable(playerStart: Position, exitPosition: Position, mazeData: MazeData): boolean {\r\n        const queue = [{ x: playerStart.x, y: playerStart.y }];\r\n        const visited = Array.from(\r\n            { length: this.boardSize },\r\n            () => Array(this.boardSize).fill(false)\r\n        );\r\n        visited[playerStart.y][playerStart.x] = true;\r\n\r\n        const directions = [\r\n            { x: 0, y: -1 },\r\n            { x: 1, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: -1, y: 0 }\r\n        ];\r\n\r\n        while (queue.length > 0) {\r\n            const { x, y } = queue.shift()!;\r\n\r\n            if (x === exitPosition.x && y === exitPosition.y) {\r\n                return true;\r\n            }\r\n\r\n            for (const dir of directions) {\r\n                const nx = x + dir.x;\r\n                const ny = y + dir.y;\r\n\r\n                if (\r\n                    nx >= 0 && nx < this.boardSize &&\r\n                    ny >= 0 && ny < this.boardSize &&\r\n                    !visited[ny][nx] &&\r\n                    !mazeData.obstacles.some(obs => obs.x === nx && obs.y === ny) &&\r\n                    !mazeData.traps.some(trap => trap.x === nx && trap.y === ny)\r\n                ) {\r\n                    visited[ny][nx] = true;\r\n                    queue.push({ x: nx, y: ny });\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Genera un laberinto simple como fallback\r\n     */\r\n    private generateSimpleMaze(exitPosition: Position): MazeData {\r\n        return {\r\n            coins: [{ x: 2, y: 2 }, { x: 5, y: 5 }, { x: 7, y: 3 }],\r\n            obstacles: [\r\n                { x: 3, y: 4, type: 'brick' },\r\n                { x: 6, y: 7, type: 'rock' }\r\n            ],\r\n            traps: [],\r\n            exitPosition\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Actualiza el tama√±o del tablero\r\n     */\r\n    setBoardSize(size: number): void {\r\n        this.boardSize = size;\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale } from '../utils/Utils';\r\nimport type { Position, Obstacle, SpriteCache, GridSprite, ObstacleSprite } from '../types/game.types';\r\n\r\n/**\r\n * Datos de entidades para renderizar\r\n */\r\nexport interface RenderData {\r\n    coins: Position[];\r\n    obstacles: Obstacle[];\r\n    traps: Position[];\r\n    saves: Position[];      // Continue power-ups\r\n    shields: Position[];    // Shield power-ups\r\n    exitPosition: Position;\r\n}\r\n\r\n/**\r\n * Renderizador del grid y entidades del juego\r\n */\r\nexport class GridRenderer {\r\n    private scene: Phaser.Scene;\r\n    private cellSize: number;\r\n    private boardSize: number;\r\n    private gridGroup: Phaser.GameObjects.Group | null = null;\r\n    private spriteCache: SpriteCache = { coins: [], obstacles: [], traps: [] };\r\n\r\n    // Entity sprites\r\n    private coinSprites: GridSprite[] = [];\r\n    private obstacleSprites: ObstacleSprite[] = [];\r\n    private trapSprites: Phaser.GameObjects.Sprite[] = [];\r\n    private exitSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private saveSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private shieldSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private exitPulseTween: Phaser.Tweens.Tween | null = null;\r\n    private savePulseTween: Phaser.Tweens.Tween | null = null;\r\n    private shieldPulseTween: Phaser.Tweens.Tween | null = null;\r\n\r\n    constructor(scene: Phaser.Scene, cellSize: number, boardSize: number) {\r\n        this.scene = scene;\r\n        this.cellSize = cellSize;\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Crea el grid visual seg√∫n el nivel\r\n     */\r\n    createGrid(level: number): void {\r\n        this.scene.cameras.main.setBackgroundColor(CONFIG.UI.MAIN_BACKGROUND_COLOR);\r\n\r\n        const neonColor = CONFIG.BACKGROUND_COLORS[(level - 1) % CONFIG.BACKGROUND_COLORS.length];\r\n\r\n        if (this.gridGroup?.children) {\r\n            this.gridGroup.clear(true, true);\r\n        } else {\r\n            this.gridGroup = this.scene.add.group();\r\n        }\r\n\r\n        const graphics = this.scene.add.graphics();\r\n        graphics.lineStyle(1, neonColor, CONFIG.GRID_ALPHA);\r\n\r\n        for (let i = 0; i <= this.boardSize; i++) {\r\n            graphics.moveTo(i * this.cellSize, 0);\r\n            graphics.lineTo(i * this.cellSize, this.boardSize * this.cellSize);\r\n            graphics.moveTo(0, i * this.cellSize);\r\n            graphics.lineTo(this.boardSize * this.cellSize, i * this.cellSize);\r\n        }\r\n\r\n        graphics.strokePath();\r\n        this.gridGroup.add(graphics);\r\n\r\n        // Add dots at intersections\r\n        for (let y = 0; y < this.boardSize; y++) {\r\n            for (let x = 0; x < this.boardSize; x++) {\r\n                const dot = this.scene.add.rectangle(\r\n                    x * this.cellSize + this.cellSize / 2,\r\n                    y * this.cellSize + this.cellSize / 2,\r\n                    2, 2, neonColor\r\n                );\r\n                dot.setAlpha(0.6);\r\n                this.gridGroup.add(dot);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dibuja todas las entidades del laberinto\r\n     */\r\n    drawEntities(data: RenderData): void {\r\n        this.drawExit(data.exitPosition);\r\n        this.drawCoins(data.coins);\r\n        this.drawObstacles(data.obstacles);\r\n        this.drawTraps(data.traps);\r\n        this.drawSave(data.saves);\r\n        this.drawShield(data.shields);\r\n        this.hideUnusedSprites();\r\n    }\r\n\r\n    /**\r\n     * Dibuja la salida con animaci√≥n pulsante\r\n     */\r\n    private drawExit(exitPosition: Position): void {\r\n        if (!this.exitSprite) {\r\n            this.exitSprite = this.scene.add.sprite(\r\n                exitPosition.x * this.cellSize + this.cellSize / 2,\r\n                exitPosition.y * this.cellSize + this.cellSize / 2,\r\n                'exit'\r\n            );\r\n        } else {\r\n            this.exitSprite.setPosition(\r\n                exitPosition.x * this.cellSize + this.cellSize / 2,\r\n                exitPosition.y * this.cellSize + this.cellSize / 2\r\n            );\r\n            this.exitSprite.setVisible(true);\r\n        }\r\n\r\n        const exitScale = calculateSpriteScale('exit', this.cellSize, this.scene);\r\n        this.exitSprite.setScale(exitScale);\r\n        this.startExitAnimation(exitScale);\r\n    }\r\n\r\n    /**\r\n     * Inicia la animaci√≥n pulsante de la salida\r\n     */\r\n    private startExitAnimation(baseScale: number): void {\r\n        if (!this.exitSprite) return;\r\n\r\n        if (this.exitPulseTween) {\r\n            this.exitPulseTween.stop();\r\n        }\r\n\r\n        this.exitPulseTween = this.scene.tweens.add({\r\n            targets: this.exitSprite,\r\n            scaleX: { from: baseScale * 0.95, to: baseScale * 1.1 },\r\n            scaleY: { from: baseScale * 0.95, to: baseScale * 1.1 },\r\n            alpha: { from: 0.7, to: 1.0 },\r\n            duration: 800,\r\n            ease: 'Sine.InOut',\r\n            yoyo: true,\r\n            repeat: -1\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja las monedas\r\n     */\r\n    private drawCoins(coins: Position[]): void {\r\n        this.coinSprites = [];\r\n        coins.forEach((coin, index) => {\r\n            let coinSprite: GridSprite;\r\n\r\n            if (this.spriteCache.coins[index]?.active) {\r\n                coinSprite = this.spriteCache.coins[index] as GridSprite;\r\n                coinSprite.setPosition(\r\n                    coin.x * this.cellSize + this.cellSize / 2,\r\n                    coin.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                coinSprite.setVisible(true);\r\n            } else {\r\n                coinSprite = this.scene.add.sprite(\r\n                    coin.x * this.cellSize + this.cellSize / 2,\r\n                    coin.y * this.cellSize + this.cellSize / 2,\r\n                    'coin'\r\n                ) as GridSprite;\r\n                const coinScale = calculateSpriteScale('coin', this.cellSize, this.scene);\r\n                coinSprite.setScale(coinScale);\r\n                this.spriteCache.coins[index] = coinSprite;\r\n            }\r\n\r\n            coinSprite.gridX = coin.x;\r\n            coinSprite.gridY = coin.y;\r\n            this.coinSprites.push(coinSprite);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja los obst√°culos\r\n     */\r\n    private drawObstacles(obstacles: Obstacle[]): void {\r\n        this.obstacleSprites = [];\r\n        obstacles.forEach((obstacle, index) => {\r\n            let obstacleSprite: ObstacleSprite;\r\n\r\n            if (this.spriteCache.obstacles[index]?.active) {\r\n                obstacleSprite = this.spriteCache.obstacles[index] as ObstacleSprite;\r\n                obstacleSprite.setPosition(\r\n                    obstacle.x * this.cellSize + this.cellSize / 2,\r\n                    obstacle.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                obstacleSprite.setTexture(`obstacle_${obstacle.type}`);\r\n                obstacleSprite.setVisible(true);\r\n            } else {\r\n                obstacleSprite = this.scene.add.sprite(\r\n                    obstacle.x * this.cellSize + this.cellSize / 2,\r\n                    obstacle.y * this.cellSize + this.cellSize / 2,\r\n                    `obstacle_${obstacle.type}`\r\n                ) as ObstacleSprite;\r\n                const obstacleScale = calculateSpriteScale(`obstacle_${obstacle.type}`, this.cellSize, this.scene);\r\n                obstacleSprite.setScale(obstacleScale);\r\n                this.spriteCache.obstacles[index] = obstacleSprite;\r\n            }\r\n\r\n            obstacleSprite.obstacleType = obstacle.type;\r\n            obstacleSprite.gridX = obstacle.x;\r\n            obstacleSprite.gridY = obstacle.y;\r\n            this.obstacleSprites.push(obstacleSprite);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja las trampas con animaci√≥n de giro\r\n     */\r\n    private drawTraps(traps: Position[]): void {\r\n        this.trapSprites = [];\r\n        traps.forEach((trap, index) => {\r\n            let trapSprite: Phaser.GameObjects.Sprite;\r\n\r\n            if (this.spriteCache.traps[index]?.active) {\r\n                trapSprite = this.spriteCache.traps[index];\r\n                trapSprite.setPosition(\r\n                    trap.x * this.cellSize + this.cellSize / 2,\r\n                    trap.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                trapSprite.setVisible(true);\r\n            } else {\r\n                trapSprite = this.scene.add.sprite(\r\n                    trap.x * this.cellSize + this.cellSize / 2,\r\n                    trap.y * this.cellSize + this.cellSize / 2,\r\n                    'trap'\r\n                );\r\n                const trapScale = calculateSpriteScale('trap', this.cellSize, this.scene);\r\n                trapSprite.setScale(trapScale);\r\n                this.spriteCache.traps[index] = trapSprite;\r\n            }\r\n\r\n            // Spinning animation with staggered start\r\n            const staggerDelay = Phaser.Math.Between(0, 2000);\r\n            this.scene.time.delayedCall(staggerDelay, () => {\r\n                if (trapSprite?.active) {\r\n                    this.scene.tweens.add({\r\n                        targets: trapSprite,\r\n                        angle: 360,\r\n                        duration: 1500,\r\n                        ease: 'Cubic.InOut',\r\n                        repeat: -1,\r\n                        onRepeat: () => trapSprite.setAngle(0)\r\n                    });\r\n                }\r\n            });\r\n\r\n            this.trapSprites.push(trapSprite);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja el save item con animaci√≥n pulsante\r\n     */\r\n    private drawSave(saves: Position[]): void {\r\n        if (saves.length > 0) {\r\n            const save = saves[0];\r\n            if (!this.saveSprite) {\r\n                this.saveSprite = this.scene.add.sprite(\r\n                    save.x * this.cellSize + this.cellSize / 2,\r\n                    save.y * this.cellSize + this.cellSize / 2,\r\n                    'power_continue'\r\n                );\r\n            } else {\r\n                this.saveSprite.setPosition(\r\n                    save.x * this.cellSize + this.cellSize / 2,\r\n                    save.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                this.saveSprite.setVisible(true);\r\n            }\r\n\r\n            const saveScale = calculateSpriteScale('power_continue', this.cellSize, this.scene);\r\n            this.saveSprite.setScale(saveScale);\r\n            this.saveSprite.setAlpha(1);\r\n\r\n            if (this.savePulseTween) {\r\n                this.savePulseTween.stop();\r\n            }\r\n\r\n            this.savePulseTween = this.scene.tweens.add({\r\n                targets: this.saveSprite,\r\n                scaleX: { from: saveScale * 0.95, to: saveScale * 1.08 },\r\n                scaleY: { from: saveScale * 0.95, to: saveScale * 1.08 },\r\n                alpha: { from: 0.9, to: 1.0 },\r\n                ease: 'Sine.InOut',\r\n                duration: 600,\r\n                yoyo: true,\r\n                repeat: -1\r\n            });\r\n        } else if (this.saveSprite) {\r\n            this.saveSprite.setVisible(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dibuja el shield item con animaci√≥n pulsante\r\n     */\r\n    private drawShield(shields: Position[]): void {\r\n        if (shields.length > 0) {\r\n            const shield = shields[0];\r\n            if (!this.shieldSprite) {\r\n                this.shieldSprite = this.scene.add.sprite(\r\n                    shield.x * this.cellSize + this.cellSize / 2,\r\n                    shield.y * this.cellSize + this.cellSize / 2,\r\n                    'power_shield'\r\n                );\r\n            } else {\r\n                this.shieldSprite.setPosition(\r\n                    shield.x * this.cellSize + this.cellSize / 2,\r\n                    shield.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                this.shieldSprite.setVisible(true);\r\n            }\r\n\r\n            const shieldScale = calculateSpriteScale('power_shield', this.cellSize, this.scene);\r\n            this.shieldSprite.setScale(shieldScale);\r\n            this.shieldSprite.setAlpha(1);\r\n\r\n            if (this.shieldPulseTween) {\r\n                this.shieldPulseTween.stop();\r\n            }\r\n\r\n            this.shieldPulseTween = this.scene.tweens.add({\r\n                targets: this.shieldSprite,\r\n                scaleX: { from: shieldScale * 0.95, to: shieldScale * 1.08 },\r\n                scaleY: { from: shieldScale * 0.95, to: shieldScale * 1.08 },\r\n                alpha: { from: 0.9, to: 1.0 },\r\n                ease: 'Sine.InOut',\r\n                duration: 600,\r\n                yoyo: true,\r\n                repeat: -1\r\n            });\r\n        } else if (this.shieldSprite) {\r\n            this.shieldSprite.setVisible(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Oculta sprites no usados del cache\r\n     */\r\n    private hideUnusedSprites(): void {\r\n        this.hideUnused(this.coinSprites, 'coins');\r\n        this.hideUnused(this.obstacleSprites, 'obstacles');\r\n        this.hideUnused(this.trapSprites, 'traps');\r\n    }\r\n\r\n    private hideUnused(usedSprites: Phaser.GameObjects.Sprite[], cacheKey: keyof SpriteCache): void {\r\n        const cache = this.spriteCache[cacheKey];\r\n        for (let i = usedSprites.length; i < cache.length; i++) {\r\n            if (cache[i]) {\r\n                cache[i].setVisible(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Anima los √°rboles cercanos cuando el jugador pasa\r\n     */\r\n    animateNearbyTrees(playerX: number, playerY: number): void {\r\n        this.obstacleSprites.forEach(sprite => {\r\n            if (sprite.obstacleType !== 'tree') return;\r\n\r\n            const distX = Math.abs((sprite.gridX ?? 0) - playerX);\r\n            const distY = Math.abs((sprite.gridY ?? 0) - playerY);\r\n\r\n            if (distX <= 1 && distY <= 1 && (distX + distY) > 0) {\r\n                if (!sprite.isSwaying) {\r\n                    sprite.isSwaying = true;\r\n                    const swayDirection = playerX < (sprite.gridX ?? 0) ? -1 : 1;\r\n\r\n                    this.scene.tweens.add({\r\n                        targets: sprite,\r\n                        angle: { from: 0, to: swayDirection * 8 },\r\n                        duration: 150,\r\n                        ease: 'Sine.InOut',\r\n                        yoyo: true,\r\n                        repeat: 1,\r\n                        onComplete: () => {\r\n                            sprite.setAngle(0);\r\n                            sprite.isSwaying = false;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Elimina una moneda del renderer\r\n     */\r\n    removeCoin(x: number, y: number): void {\r\n        for (let i = this.coinSprites.length - 1; i >= 0; i--) {\r\n            if (this.coinSprites[i].gridX === x && this.coinSprites[i].gridY === y) {\r\n                this.coinSprites[i].destroy();\r\n                this.coinSprites.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Elimina el save sprite\r\n     */\r\n    removeSave(): void {\r\n        if (this.savePulseTween) {\r\n            this.savePulseTween.stop();\r\n            this.savePulseTween = null;\r\n        }\r\n        if (this.saveSprite) {\r\n            this.saveSprite.destroy();\r\n            this.saveSprite = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Elimina el shield sprite\r\n     */\r\n    removeShield(): void {\r\n        if (this.shieldPulseTween) {\r\n            this.shieldPulseTween.stop();\r\n            this.shieldPulseTween = null;\r\n        }\r\n        if (this.shieldSprite) {\r\n            this.shieldSprite.destroy();\r\n            this.shieldSprite = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtiene los sprites de monedas\r\n     */\r\n    getCoinSprites(): GridSprite[] {\r\n        return this.coinSprites;\r\n    }\r\n\r\n    /**\r\n     * Obtiene los sprites de obst√°culos\r\n     */\r\n    getObstacleSprites(): ObstacleSprite[] {\r\n        return this.obstacleSprites;\r\n    }\r\n\r\n    /**\r\n     * Limpia el cache de sprites\r\n     */\r\n    clearCache(): void {\r\n        Object.keys(this.spriteCache).forEach(key => {\r\n            const cacheKey = key as keyof SpriteCache;\r\n            this.spriteCache[cacheKey].forEach(sprite => {\r\n                if (sprite?.destroy) {\r\n                    sprite.destroy();\r\n                }\r\n            });\r\n            this.spriteCache[cacheKey] = [];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.clearCache();\r\n        if (this.exitPulseTween) this.exitPulseTween.stop();\r\n        if (this.savePulseTween) this.savePulseTween.stop();\r\n        if (this.shieldPulseTween) this.shieldPulseTween.stop();\r\n        if (this.exitSprite) this.exitSprite.destroy();\r\n        if (this.saveSprite) this.saveSprite.destroy();\r\n        if (this.shieldSprite) this.shieldSprite.destroy();\r\n        if (this.gridGroup) this.gridGroup.clear(true, true);\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\n\r\n// Managers\r\nimport { InputManager } from '../managers/InputManager';\r\nimport { AudioManager } from '../managers/AudioManager';\r\nimport { PlayerController } from '../managers/PlayerController';\r\nimport { EnemyManager } from '../managers/EnemyManager';\r\nimport { SpiderManager } from '../managers/SpiderManager';\r\nimport { UIManager } from '../managers/UIManager';\r\nimport { GameStateManager } from '../managers/GameStateManager';\r\n\r\n// Systems\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport { MazeGenerator, type MazeData } from '../systems/MazeGenerator';\r\nimport { GridRenderer } from '../systems/GridRenderer';\r\n\r\nimport type { Position, Direction } from '../types/game.types';\r\nimport type { DevModeData } from './MenuScene';\r\n\r\n/**\r\n * Escena principal del juego - Act√∫a como orquestador de todos los managers\r\n */\r\nexport class GameScene extends Phaser.Scene {\r\n    // Configuration\r\n    private boardSize: number;\r\n    private cellSize: number;\r\n\r\n    // Managers\r\n    private inputManager!: InputManager;\r\n    private audioManager!: AudioManager;\r\n    private playerController!: PlayerController;\r\n    private enemyManager!: EnemyManager;\r\n    private spiderManager!: SpiderManager;\r\n    private uiManager!: UIManager;\r\n    private gameState!: GameStateManager;\r\n\r\n    // Systems\r\n    private collision!: CollisionSystem;\r\n    private mazeGenerator!: MazeGenerator;\r\n    private gridRenderer!: GridRenderer;\r\n\r\n    // Game Data\r\n    private mazeData!: MazeData;\r\n    private saves: Position[] = [];      // Continue power-ups\r\n    private shields: Position[] = [];    // Shield power-ups\r\n    private playerStartPosition: Position = { x: 0, y: 0 };\r\n    private shieldSpawned: boolean = false;   // Track if shield already spawned this level\r\n    private continueSpawned: boolean = false; // Track if continue already spawned this level\r\n\r\n    // Optimization\r\n    private lastEnemyUpdateTime: number = 0;\r\n    private requireFreshPressAfterReset: boolean = false;\r\n    private invincibilityEndTime: number = 0; // Temporal invincibility after shield use\r\n\r\n    constructor() {\r\n        super('GameScene');\r\n        this.boardSize = CONFIG.BOARD_SIZE;\r\n        this.cellSize = CONFIG.CELL_SIZE;\r\n    }\r\n\r\n    preload(): void {\r\n        try {\r\n            // Load images\r\n            this.load.image('player_stand', 'lucy_stand.png');\r\n            this.load.image('player_run', 'lucy_run.png');\r\n            this.load.image('player_die', 'lucy_die.png');\r\n            this.load.image('coin', 'coin_tuto.png');\r\n            this.load.image('obstacle_brick', 'brick_1.png');\r\n            this.load.image('obstacle_rock', 'rock_1.png');\r\n            this.load.image('obstacle_tree', 'tree_1.png');\r\n            this.load.image('trap', 'sping.png');\r\n            this.load.image('exit', 'exit.png');\r\n            this.load.image('enemy', 'enemy.png');\r\n            this.load.image('spider', 'enemy_spider.png');\r\n            this.load.image('power_continue', 'power_continue.png');\r\n            this.load.image('power_shield', 'power_shield.png');\r\n\r\n            // Initialize audio manager early for preload\r\n            this.audioManager = new AudioManager(this);\r\n            this.audioManager.detectAndLoadMusic();\r\n        } catch (error) {\r\n            console.error('Critical error in preload:', error);\r\n        }\r\n    }\r\n\r\n    create(data?: DevModeData): void {\r\n        // Initialize all managers and systems\r\n        this.initializeManagers();\r\n\r\n        // Apply dev mode data if provided\r\n        if (data && data.enabled) {\r\n            this.gameState.applyDevMode(data.level, data.shields, data.continues, data.score);\r\n        }\r\n\r\n        // Setup event listeners\r\n        this.setupEvents();\r\n\r\n        // Generate initial maze\r\n        this.startNewGame();\r\n\r\n        // Initialize audio\r\n        this.audioManager.initMusic();\r\n\r\n        // Setup UI event listeners\r\n        this.uiManager.setupEventListeners({\r\n            onMusicToggle: () => {\r\n                this.audioManager.togglePlayPause();\r\n                this.uiManager.updateMusicButtonState(this.audioManager.isPlaying());\r\n            },\r\n            onMusicStop: () => {\r\n                this.audioManager.stop();\r\n                this.uiManager.updateMusicButtonState(false);\r\n            },\r\n            onVolumeChange: (vol) => this.audioManager.setVolume(vol),\r\n            onNextMusic: () => {\r\n                this.audioManager.playNext();\r\n                this.uiManager.updateMusicButtonState(this.audioManager.isPlaying());\r\n            },\r\n            onMenu: () => this.returnToMenu(),\r\n            onContinue: () => this.handleContinueButton(),\r\n            onRestart: () => this.handleRestartButton()\r\n        });\r\n\r\n        // Update initial UI\r\n        this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n        this.updatePowerUpsUI();\r\n    }\r\n\r\n    update(time: number, _delta: number): void {\r\n        // Global inputs (Available anytime)\r\n        if (this.inputManager.isMenuJustPressed()) {\r\n            this.returnToMenu();\r\n            return;\r\n        }\r\n\r\n        if (this.inputManager.isRestartJustPressed()) {\r\n            this.handleRestartButton();\r\n            return;\r\n        }\r\n\r\n        // Handle game over input\r\n        if (this.gameState.isGameOver) {\r\n            // C = Continue (only available in game over)\r\n            if (this.inputManager.isContinueJustPressed()) {\r\n                this.handleContinueButton();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Update enemies with throttling\r\n        if (time > this.lastEnemyUpdateTime + CONFIG.PERFORMANCE.ENEMY_UPDATE_THROTTLE_MS) {\r\n            this.enemyManager.update();\r\n\r\n            // Update spiders and check collision\r\n            const playerPos = this.playerController.getPosition();\r\n            const playerHit = this.spiderManager.update(time, playerPos);\r\n            // Only handle hit if not already game over (invincibility is checked in handleDeath)\r\n            if (playerHit && !this.gameState.isGameOver) {\r\n                this.handleDeath();\r\n            }\r\n\r\n            this.lastEnemyUpdateTime = time;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inicializa todos los managers y sistemas\r\n     */\r\n    private initializeManagers(): void {\r\n        // Core systems\r\n        this.collision = new CollisionSystem(this.boardSize);\r\n        this.mazeGenerator = new MazeGenerator(this.boardSize);\r\n        this.gridRenderer = new GridRenderer(this, this.cellSize, this.boardSize);\r\n\r\n        // Managers\r\n        this.inputManager = new InputManager(this);\r\n        // audioManager already initialized in preload\r\n        this.playerController = new PlayerController(this, this.collision, this.cellSize);\r\n        this.enemyManager = new EnemyManager(this, this.collision, this.cellSize);\r\n        this.spiderManager = new SpiderManager(this, this.collision, this.cellSize, this.boardSize);\r\n        this.uiManager = new UIManager();\r\n        this.gameState = new GameStateManager(this);\r\n\r\n        // Setup input\r\n        this.inputManager.setup();\r\n\r\n        // Setup turn callbacks for direction change during movement\r\n        this.playerController.setTurnCallbacks(\r\n            () => this.inputManager.getDesiredDirection(),\r\n            (dx, dy) => this.handlePlayerMove({ dx, dy })\r\n        );\r\n\r\n        // Create game over UI\r\n        this.gameState.createGameOverUI();\r\n    }\r\n\r\n    /**\r\n     * Configura los eventos entre managers\r\n     */\r\n    private setupEvents(): void {\r\n        // Input direction event\r\n        this.events.on('input:direction', (direction: Direction) => {\r\n            if (!this.playerController.getIsMoving() &&\r\n                !this.gameState.isGameOver &&\r\n                (direction.dx !== 0 || direction.dy !== 0)) {\r\n                this.handlePlayerMove(direction);\r\n                this.requireFreshPressAfterReset = false;\r\n            }\r\n        });\r\n\r\n        // Player events\r\n        this.events.on('player:died', () => {\r\n            this.handleDeath();\r\n        });\r\n\r\n        this.events.on('player:reachedExit', () => {\r\n            this.handleLevelComplete();\r\n        });\r\n\r\n        // Enemy moved event (check collision with player)\r\n        this.events.on('enemy:moved', (pos: Position) => {\r\n            const playerPos = this.playerController.getPosition();\r\n            if (pos.x === playerPos.x && pos.y === playerPos.y) {\r\n                this.handleDeath();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Inicia un nuevo juego\r\n     */\r\n    private startNewGame(): void {\r\n        // Generate maze\r\n        const exitPosition = this.mazeGenerator.generateRandomExit();\r\n        this.mazeData = this.mazeGenerator.generate(exitPosition);\r\n        this.saves = [];\r\n\r\n        // Build collision map\r\n        this.collision.build(this.mazeData.obstacles);\r\n\r\n        // Store initial coin count\r\n        this.gameState.initialCoinCount = this.mazeData.coins.length;\r\n\r\n        // Create grid and draw entities\r\n        this.gridRenderer.createGrid(this.gameState.level);\r\n        this.gridRenderer.drawEntities({\r\n            coins: this.mazeData.coins,\r\n            obstacles: this.mazeData.obstacles,\r\n            traps: this.mazeData.traps,\r\n            saves: this.saves,\r\n            shields: this.shields,\r\n            exitPosition: this.mazeData.exitPosition\r\n        });\r\n\r\n        // Create player\r\n        this.playerController.create(this.playerStartPosition);\r\n\r\n        // Initialize enemies (level 5+)\r\n        const excludePositions = [\r\n            this.playerStartPosition,\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps\r\n        ];\r\n        this.enemyManager.init(this.gameState.level, excludePositions);\r\n\r\n        // Initialize spiders\r\n        this.spiderManager.generate(\r\n            this.gameState.level,\r\n            this.mazeData.obstacles,\r\n            this.mazeData.exitPosition\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Maneja el movimiento del jugador\r\n     */\r\n    private handlePlayerMove(direction: Direction): void {\r\n        this.playerController.move(\r\n            direction.dx,\r\n            direction.dy,\r\n            this.gameState.level,\r\n            this.mazeData.traps,\r\n            this.mazeData.exitPosition,\r\n            (x, y) => this.enemyManager.checkCollision(x, y) || this.spiderManager.checkCollision(x, y),\r\n            (x, y) => this.processItemsAtPosition(x, y)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Procesa items en la posici√≥n del jugador\r\n     */\r\n    private processItemsAtPosition(x: number, y: number): void {\r\n        // Check coins\r\n        for (let i = this.mazeData.coins.length - 1; i >= 0; i--) {\r\n            if (this.mazeData.coins[i].x === x && this.mazeData.coins[i].y === y) {\r\n                this.playerController.emitCoinParticles(x, y);\r\n                this.mazeData.coins.splice(i, 1);\r\n                this.gameState.addScore(10);\r\n                this.uiManager.updateScore(this.gameState.score);\r\n                this.gridRenderer.removeCoin(x, y);\r\n\r\n                // Check power-up spawn triggers based on coins collected\r\n                if (this.gameState.initialCoinCount > 0) {\r\n                    const collected = this.gameState.initialCoinCount - this.mazeData.coins.length;\r\n                    const ratio = collected / this.gameState.initialCoinCount;\r\n\r\n                    // Power-up spawns at configured ratio (only ONE per level)\r\n                    if (ratio >= CONFIG.POWERUPS.SPAWN_COIN_RATIO && !this.shieldSpawned && !this.continueSpawned) {\r\n                        // Shield has higher probability than continue\r\n                        if (Math.random() < CONFIG.POWERUPS.SHIELD_PROBABILITY) {\r\n                            this.generateShieldItem();\r\n                            this.shieldSpawned = true;\r\n                        } else {\r\n                            this.generateSaveItem();\r\n                            this.continueSpawned = true;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Check shield collection\r\n        if (this.shields.length > 0) {\r\n            const shield = this.shields[0];\r\n            if (shield.x === x && shield.y === y) {\r\n                this.gameState.addShield();\r\n                this.shields.splice(0, 1);\r\n                this.gridRenderer.removeShield();\r\n                this.updatePowerUpsUI();\r\n            }\r\n        }\r\n\r\n        // Check continue collection\r\n        if (this.saves.length > 0) {\r\n            const save = this.saves[0];\r\n            if (save.x === x && save.y === y) {\r\n                this.gameState.addContinue();\r\n                this.saves.splice(0, 1);\r\n                this.gridRenderer.removeSave();\r\n                this.updatePowerUpsUI();\r\n            }\r\n        }\r\n\r\n        // Animate nearby trees\r\n        this.gridRenderer.animateNearbyTrees(x, y);\r\n    }\r\n\r\n    /**\r\n     * Genera un save item (continue power-up)\r\n     */\r\n    private generateSaveItem(): void {\r\n        const excludePositions = [\r\n            this.playerController.getPosition(),\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps,\r\n            ...this.enemyManager.getEnemies().map(e => ({ x: e.x, y: e.y })),\r\n            ...this.shields\r\n        ];\r\n\r\n        const position = this.mazeGenerator.generateSaveItem(excludePositions);\r\n        if (position && this.saves.length === 0) {\r\n            this.saves.push(position);\r\n            this.gridRenderer.drawEntities({\r\n                coins: this.mazeData.coins,\r\n                obstacles: this.mazeData.obstacles,\r\n                traps: this.mazeData.traps,\r\n                saves: this.saves,\r\n                shields: this.shields,\r\n                exitPosition: this.mazeData.exitPosition\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Genera un shield item\r\n     */\r\n    private generateShieldItem(): void {\r\n        const excludePositions = [\r\n            this.playerController.getPosition(),\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps,\r\n            ...this.enemyManager.getEnemies().map(e => ({ x: e.x, y: e.y })),\r\n            ...this.saves\r\n        ];\r\n\r\n        const position = this.mazeGenerator.generateSaveItem(excludePositions);\r\n        if (position && this.shields.length === 0) {\r\n            this.shields.push(position);\r\n            this.gridRenderer.drawEntities({\r\n                coins: this.mazeData.coins,\r\n                obstacles: this.mazeData.obstacles,\r\n                traps: this.mazeData.traps,\r\n                saves: this.saves,\r\n                shields: this.shields,\r\n                exitPosition: this.mazeData.exitPosition\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maneja la muerte del jugador\r\n     * Primero intenta usar shield (flash sin detener), luego game over\r\n     * Verifica invincibilidad para evitar consumo m√∫ltiple de shields\r\n     */\r\n    private handleDeath(): void {\r\n        const currentTime = this.time.now;\r\n\r\n        // Skip if currently invincible (shield was just used)\r\n        if (currentTime < this.invincibilityEndTime) {\r\n            return;\r\n        }\r\n\r\n        // Try to use shield first\r\n        if (this.gameState.useShield()) {\r\n            // Shield absorbed the hit - flash player and continue movement\r\n            this.playerController.flashInvincibility();\r\n            this.updatePowerUpsUI();\r\n            // Set invincibility window to prevent multiple shield consumption\r\n            this.invincibilityEndTime = currentTime + CONFIG.POWERUPS.SHIELD_INVINCIBILITY_MS;\r\n            return;\r\n        }\r\n\r\n        // No shield - game over\r\n        this.gameState.isGameOver = true;\r\n        this.playerController.stopMovement();\r\n        this.playerController.showDeathSprite();\r\n        this.gameState.showGameOver();\r\n    }\r\n\r\n    /**\r\n     * Maneja la completaci√≥n del nivel\r\n     */\r\n    private handleLevelComplete(): void {\r\n        this.gameState.nextLevel();\r\n        this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n        this.playerController.stopMovement();\r\n        this.requireFreshPressAfterReset = true;\r\n        this.inputManager.resetDesiredDirection();\r\n        this.resetGame(false);\r\n    }\r\n\r\n    /**\r\n     * Resetea el juego\r\n     */\r\n    private resetGame(fullReset: boolean): void {\r\n        // Clear caches\r\n        this.gridRenderer.clearCache();\r\n        this.enemyManager.reset();\r\n        this.spiderManager.reset();\r\n\r\n        // Generate new maze\r\n        const exitPosition = this.mazeGenerator.generateRandomExit();\r\n        this.mazeData = this.mazeGenerator.generate(exitPosition);\r\n\r\n        // Reset power-up items and spawn flags\r\n        this.saves = [];\r\n        this.shields = [];\r\n        this.shieldSpawned = false;\r\n        this.continueSpawned = false;\r\n\r\n        // Rebuild collision\r\n        this.collision.build(this.mazeData.obstacles);\r\n        this.gameState.initialCoinCount = this.mazeData.coins.length;\r\n\r\n        // Redraw\r\n        this.gridRenderer.createGrid(this.gameState.level);\r\n        this.gridRenderer.drawEntities({\r\n            coins: this.mazeData.coins,\r\n            obstacles: this.mazeData.obstacles,\r\n            traps: this.mazeData.traps,\r\n            saves: this.saves,\r\n            shields: this.shields,\r\n            exitPosition: this.mazeData.exitPosition\r\n        });\r\n\r\n        // Reset player\r\n        this.playerController.reset(this.playerStartPosition);\r\n\r\n        // Re-init enemies\r\n        const excludePositions = [\r\n            this.playerStartPosition,\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps\r\n        ];\r\n        this.enemyManager.init(this.gameState.level, excludePositions);\r\n        this.spiderManager.generate(\r\n            this.gameState.level,\r\n            this.mazeData.obstacles,\r\n            this.mazeData.exitPosition\r\n        );\r\n\r\n        // Hide game over UI\r\n        this.gameState.hideGameOverUI();\r\n    }\r\n\r\n    /**\r\n     * Maneja el bot√≥n de Continue de UI\r\n     */\r\n    private handleContinueButton(): void {\r\n        if (this.gameState.isGameOver && this.gameState.useContinue()) {\r\n            this.gameState.isGameOver = false;\r\n            this.updatePowerUpsUI();\r\n            this.resetGame(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maneja el bot√≥n de restart de UI (siempre hace full reset)\r\n     */\r\n    private handleRestartButton(): void {\r\n        this.gameState.reset(true);\r\n        this.updatePowerUpsUI();\r\n        this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n        this.resetGame(true);\r\n    }\r\n\r\n    /**\r\n     * Actualiza la UI de power-ups\r\n     */\r\n    private updatePowerUpsUI(): void {\r\n        this.uiManager.updatePowerUps(\r\n            this.gameState.shieldCount,\r\n            this.gameState.continueCount\r\n        );\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Retorna al men√∫ principal\r\n     */\r\n    private returnToMenu(): void {\r\n        this.audioManager.stop();\r\n        this.gameState.returnToMenu();\r\n    }\r\n\r\n    /**\r\n     * Cleanup al destruir la escena\r\n     */\r\n    shutdown(): void {\r\n        this.inputManager?.destroy();\r\n        this.audioManager?.destroy();\r\n        this.playerController?.destroy();\r\n        this.enemyManager?.destroy();\r\n        this.spiderManager?.destroy();\r\n        this.uiManager?.destroy();\r\n        this.gameState?.destroy();\r\n        this.gridRenderer?.destroy();\r\n\r\n        this.events.off('input:direction');\r\n        this.events.off('player:died');\r\n        this.events.off('player:reachedExit');\r\n        this.events.off('enemy:moved');\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from './Config';\r\nimport { MenuScene } from './scenes/MenuScene';\r\nimport { GameScene } from './scenes/GameScene';\r\n\r\nconst config: Phaser.Types.Core.GameConfig = {\r\n    type: Phaser.AUTO,\r\n    width: CONFIG.GAME_WIDTH,\r\n    height: CONFIG.GAME_HEIGHT,\r\n    backgroundColor: CONFIG.UI.MAIN_BACKGROUND_COLOR,\r\n    parent: 'game-container',\r\n    pixelArt: true,\r\n    scale: {\r\n        mode: Phaser.Scale.FIT,\r\n        autoCenter: Phaser.Scale.CENTER_BOTH\r\n    },\r\n    scene: [MenuScene, GameScene]\r\n};\r\n\r\nnew Phaser.Game(config);\r\n"],"names":["CONFIG","HIGH_SCORE_KEY","ScoreManager","stored","score","current","MenuScene","Phaser","centerX","centerY","playerLogo","playButton","highScore","devButton","pointer","panelX","panelY","bg","title","row","index","y","label","minus","step","value","plus","applyBtn","key","InputManager","scene","event","dx","dy","absDx","absDy","_a","AudioManager","maxTracks","file","keyIndex","i","filename","error","tryStartMusic","j","musicKey","soundManager","_b","volume","calculateSpriteScale","textureKey","targetSize","sourceImage","originalWidth","originalHeight","generateFreePosition","excludePositions","boardSize","maxAttempts","attempts","position","pos","PlayerController","collision","cellSize","getDesiredDirection","onTurnMove","level","traps","exitPosition","checkEnemyCollision","onStepCallback","moveResult","baseStepDuration","finalDestination","baseMs","fastDecPerLevel","slowDecPerLevel","tinyDecPerLevel","phase1Limit","phase2Limit","minMs","duration","phase1Duration","extraLevels","phase2Duration","startX","startY","checkX","checkY","lastStepProcessed","tween","progress","currentStep","stepStart","newX","newY","gameState","desiredDirection","turnNextX","turnNextY","playerScale","x","dieScale","EnemyManager","enemyCount","secondEnemyLevel","allExcluded","e","enemy","enemyScale","nextX","nextY","wallCollision","enemyCollision","excludeIndex","playerX","playerY","directions","SpiderManager","obstacles","spiderCount","spiderAdded","pointA","axis","pointB","spider","spiderScale","time","playerPosition","playerHit","speed","p","o","s","UIManager","safeScore","scoreElement","safeLevel","levelElement","shields","continues","shieldsElement","continuesElement","isPlaying","callbacks","stopMusicButton","volumeSlider","nextButton","menuButton","continueButton","restartButton","addListener","element","handler","target","GameStateManager","isNewRecord","_c","menuOffsetY","_d","_e","points","fullReset","CollisionSystem","obstacle","trap","currentX","currentY","distance","start","end","currX","currY","size","MazeGenerator","playerStart","mazeData","coins","obstacleTypes","randomType","freeSpaces","dir","nx","ny","obs","queue","visited","GridRenderer","neonColor","graphics","dot","data","exitScale","baseScale","coin","coinSprite","coinScale","obstacleSprite","obstacleScale","trapSprite","trapScale","staggerDelay","saves","save","saveScale","shield","shieldScale","usedSprites","cacheKey","cache","sprite","distX","distY","swayDirection","GameScene","vol","_delta","playerPos","direction","currentTime","_f","_g","_h","config"],"mappings":"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"}