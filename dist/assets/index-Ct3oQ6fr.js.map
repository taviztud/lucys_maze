{"version":3,"file":"index-Ct3oQ6fr.js","sources":["../../src/Config.ts","../../src/managers/ScoreManager.ts","../../src/scenes/MenuScene.ts","../../src/managers/InputManager.ts","../../src/managers/AudioManager.ts","../../src/utils/Utils.ts","../../src/managers/PlayerController.ts","../../src/managers/EnemyManager.ts","../../src/managers/SpiderManager.ts","../../src/managers/UIManager.ts","../../src/managers/GameStateManager.ts","../../src/systems/CollisionSystem.ts","../../src/systems/MazeGenerator.ts","../../src/systems/GridRenderer.ts","../../src/scenes/GameScene.ts","../../src/main.ts"],"sourcesContent":["import type { GameConfig } from './types/game.types';\r\n\r\nexport const CONFIG: GameConfig = {\r\n    // Configuración del juego\r\n    GAME_WIDTH: 600,\r\n    GAME_HEIGHT: 600,\r\n    BOARD_SIZE: 10,\r\n    CELL_SIZE: 60,\r\n\r\n    // Configuraciones de gameplay\r\n    MAZE_GENERATION: {\r\n        OBSTACLE_PROBABILITY: 0.2,\r\n        COIN_PROBABILITY: 0.1,\r\n        TRAP_PROBABILITY: 0.05,\r\n        MAX_ATTEMPTS: 100,\r\n        MIN_FREE_SPACES: 4\r\n    },\r\n\r\n    // Configuración de música y audio\r\n    AUDIO: {\r\n        DEFAULT_VOLUME: 0.5,\r\n        MAX_BG_TRACKS: 14\r\n    },\r\n\r\n    // UI y efectos visuales\r\n    UI: {\r\n        GAME_OVER_FONT_SIZE: '48px',\r\n        RESTART_FONT_SIZE: '24px',\r\n        RESTART_OFFSET_Y: 80,\r\n        EXIT_BLINK_ALPHA_HIGH: 1,\r\n        EXIT_BLINK_ALPHA_LOW: 0.3,\r\n        EXIT_BLINK_INTERVAL: 200,\r\n        FONT_FAMILY: '\"Press Start 2P\", cursive',\r\n        MAIN_BACKGROUND_COLOR: '#1e1e2e'\r\n    },\r\n\r\n    // Colores de NEÓN por nivel\r\n    BACKGROUND_COLORS: [0x4CC9F0, 0xF72585, 0x4AD66D, 0xF4D35E, 0x7209B7],\r\n    GRID_ALPHA: 0.15,\r\n\r\n    // Configuración de enemigos\r\n    ENEMIES: {\r\n        MIN_LEVEL_FOR_TWO: 10,\r\n        SINGLE_COUNT: 1,\r\n        DOUBLE_COUNT: 2,\r\n        MOVE_TWEEN_DURATION_MS: 1000,\r\n        FIRST_SPAWN_LEVEL: 5,\r\n        SECOND_ENEMY_INTERVAL: 7,\r\n        MAX_COUNT: 4\r\n    },\r\n\r\n    // Configuración de arañas\r\n    SPIDER: {\r\n        MIN_PATROL_DISTANCE: 3,\r\n        WAIT_DURATION_MS: 2000,\r\n        MOVE_SPEED: 0.05,\r\n        FIRST_SPAWN_LEVEL: 10,\r\n        SECOND_SPAWN_LEVEL: 15,\r\n        THIRD_SPAWN_LEVEL: 20\r\n    },\r\n\r\n    // Configuración de power-ups\r\n    POWERUPS: {\r\n        SPAWN_COIN_RATIO: 0.8,\r\n        SHIELD_PROBABILITY: 0.8\r\n    },\r\n\r\n    PERFORMANCE: {\r\n        INPUT_THROTTLE_MS: 16,\r\n        ENEMY_UPDATE_THROTTLE_MS: 16,\r\n        PLAYER_MIN_STEP_DURATION_MS: 200,\r\n        PLAYER_BASE_DURATION_MS: 400,\r\n        PLAYER_STEP_DEC_PER_LEVEL: 20\r\n    },\r\n\r\n    DEBUG: false\r\n};\r\n","const HIGH_SCORE_KEY = 'lucys_maze_high_score';\r\n\r\nexport class ScoreManager {\r\n    /**\r\n     * Get the current high score from localStorage\r\n     */\r\n    static getHighScore(): number {\r\n        try {\r\n            const stored = localStorage.getItem(HIGH_SCORE_KEY);\r\n            return stored ? parseInt(stored, 10) : 0;\r\n        } catch {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Save a new high score if it beats the current record\r\n     */\r\n    static setHighScore(score: number): boolean {\r\n        try {\r\n            const current = this.getHighScore();\r\n            if (score > current) {\r\n                localStorage.setItem(HIGH_SCORE_KEY, score.toString());\r\n                return true;\r\n            }\r\n            return false;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a score is a new high score\r\n     */\r\n    static isNewHighScore(score: number): boolean {\r\n        return score > this.getHighScore();\r\n    }\r\n\r\n    /**\r\n     * Reset the high score (for testing)\r\n     */\r\n    static reset(): void {\r\n        try {\r\n            localStorage.removeItem(HIGH_SCORE_KEY);\r\n        } catch {\r\n            // Ignore errors\r\n        }\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { ScoreManager } from '../managers/ScoreManager';\r\n\r\nexport class MenuScene extends Phaser.Scene {\r\n    constructor() {\r\n        super('MenuScene');\r\n    }\r\n\r\n    preload() {\r\n        // Load player image for logo\r\n        this.load.image('player_stand', 'lucy_stand.png');\r\n    }\r\n\r\n    create() {\r\n        const centerX = CONFIG.GAME_WIDTH / 2;\r\n        const centerY = CONFIG.GAME_HEIGHT / 2;\r\n\r\n        // Background\r\n        this.cameras.main.setBackgroundColor(CONFIG.UI.MAIN_BACKGROUND_COLOR);\r\n\r\n        // Title - neon theme colors matching the game\r\n        const title = this.add.text(centerX, centerY - 180, \"LUCY'S MAZE\", {\r\n            fontSize: '32px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#F72585',\r\n            stroke: '#ff6600',\r\n            strokeThickness: 3\r\n        });\r\n        title.setOrigin(0.5);\r\n\r\n        // Subtitle with neon cyan\r\n        const subtitle = this.add.text(centerX, centerY - 130, '¡Ayuda a Lucy a encontrar la salida!', {\r\n            fontSize: '14px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#4CC9F0'\r\n        });\r\n        subtitle.setOrigin(0.5);\r\n\r\n        // Player sprite as logo\r\n        const playerLogo = this.add.sprite(centerX, centerY + 60, 'player_stand');\r\n        playerLogo.setScale(3);\r\n        playerLogo.setOrigin(0.5, 1);  // Origin at feet so animation scales from bottom\r\n\r\n        // Subtle breathing/idle animation - feet stay grounded\r\n        this.tweens.add({\r\n            targets: playerLogo,\r\n            scaleY: 3.08,         // Slight vertical stretch (breathing in)\r\n            scaleX: 2.95,         // Slight horizontal compress\r\n            duration: 1200,\r\n            yoyo: true,\r\n            repeat: -1,\r\n            ease: 'Sine.InOut'\r\n        });\r\n\r\n        // Play button\r\n        const playButton = this.add.text(centerX, centerY + 80, '▶ JUGAR', {\r\n            fontSize: '24px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#00ff00',\r\n            backgroundColor: '#003300',\r\n            padding: { x: 30, y: 15 }\r\n        });\r\n        playButton.setOrigin(0.5);\r\n        playButton.setInteractive({ useHandCursor: true });\r\n\r\n        // Hover effects\r\n        playButton.on('pointerover', () => {\r\n            playButton.setStyle({ color: '#ffffff', backgroundColor: '#006600' });\r\n            playButton.setScale(1.1);\r\n        });\r\n        playButton.on('pointerout', () => {\r\n            playButton.setStyle({ color: '#00ff00', backgroundColor: '#003300' });\r\n            playButton.setScale(1);\r\n        });\r\n        playButton.on('pointerdown', () => {\r\n            this.startGame();\r\n        });\r\n\r\n        // High score display\r\n        const highScore = ScoreManager.getHighScore();\r\n        const highScoreText = this.add.text(centerX, centerY + 160, `RÉCORD: ${highScore}`, {\r\n            fontSize: '16px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#ff00ff'\r\n        });\r\n        highScoreText.setOrigin(0.5);\r\n\r\n        // Instructions\r\n        const instructions = this.add.text(centerX, centerY + 220, 'Usa las flechas ← ↑ → ↓ o desliza', {\r\n            fontSize: '12px',\r\n            fontFamily: CONFIG.UI.FONT_FAMILY,\r\n            color: '#888888'\r\n        });\r\n        instructions.setOrigin(0.5);\r\n\r\n        // Allow starting with Enter or Space\r\n        this.input.keyboard.on('keydown-ENTER', () => this.startGame());\r\n        this.input.keyboard.on('keydown-SPACE', () => this.startGame());\r\n\r\n        // Touch to start\r\n        this.input.on('pointerdown', (pointer) => {\r\n            // Only start if not clicking the button\r\n            if (pointer.y < centerY + 50 || pointer.y > centerY + 120) {\r\n                // Do nothing, let button handle it\r\n            }\r\n        });\r\n    }\r\n\r\n    startGame() {\r\n        this.cameras.main.fadeOut(300, 0, 0, 0);\r\n        this.time.delayedCall(300, () => {\r\n            this.scene.start('GameScene');\r\n        });\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport type { Direction } from '../types/game.types';\r\n\r\n/**\r\n * Gestor de entrada para controles de teclado y touch\r\n * Emite eventos cuando se detecta input direccional\r\n */\r\nexport class InputManager {\r\n    private scene: Phaser.Scene;\r\n    private cursors: Phaser.Types.Input.Keyboard.CursorKeys;\r\n    private restartKey: Phaser.Input.Keyboard.Key;\r\n    private menuKey: Phaser.Input.Keyboard.Key;\r\n    private continueKey: Phaser.Input.Keyboard.Key;\r\n    private desiredDirection: Direction = { dx: 0, dy: 0 };\r\n    private swipeStartX: number = 0;\r\n    private swipeStartY: number = 0;\r\n    private readonly minSwipeDistance: number = 30;\r\n\r\n    constructor(scene: Phaser.Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Inicializa todos los controles\r\n     */\r\n    setup(): void {\r\n        this.setupKeyboardControls();\r\n        this.setupTouchControls();\r\n    }\r\n\r\n    /**\r\n     * Configura los controles de teclado\r\n     */\r\n    private setupKeyboardControls(): void {\r\n        this.cursors = this.scene.input.keyboard!.createCursorKeys();\r\n        this.restartKey = this.scene.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.R);\r\n        this.menuKey = this.scene.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.M);\r\n        this.continueKey = this.scene.input.keyboard!.addKey(Phaser.Input.Keyboard.KeyCodes.C);\r\n\r\n        this.scene.input.keyboard!.on('keydown', (event: KeyboardEvent) => {\r\n            switch (event.code) {\r\n                case 'ArrowLeft':\r\n                    this.desiredDirection = { dx: -1, dy: 0 };\r\n                    break;\r\n                case 'ArrowRight':\r\n                    this.desiredDirection = { dx: 1, dy: 0 };\r\n                    break;\r\n                case 'ArrowUp':\r\n                    this.desiredDirection = { dx: 0, dy: -1 };\r\n                    break;\r\n                case 'ArrowDown':\r\n                    this.desiredDirection = { dx: 0, dy: 1 };\r\n                    break;\r\n                default:\r\n                    return; // Don't emit event for other keys\r\n            }\r\n\r\n            this.scene.events.emit('input:direction', this.desiredDirection);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Configura los controles táctiles (swipe)\r\n     */\r\n    private setupTouchControls(): void {\r\n        this.scene.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {\r\n            this.swipeStartX = pointer.x;\r\n            this.swipeStartY = pointer.y;\r\n        });\r\n\r\n        this.scene.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {\r\n            const dx = pointer.x - this.swipeStartX;\r\n            const dy = pointer.y - this.swipeStartY;\r\n            const absDx = Math.abs(dx);\r\n            const absDy = Math.abs(dy);\r\n\r\n            if (Math.max(absDx, absDy) < this.minSwipeDistance) return;\r\n\r\n            if (absDx > absDy) {\r\n                this.desiredDirection = { dx: dx > 0 ? 1 : -1, dy: 0 };\r\n            } else {\r\n                this.desiredDirection = { dx: 0, dy: dy > 0 ? 1 : -1 };\r\n            }\r\n\r\n            this.scene.events.emit('input:direction', this.desiredDirection);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si la tecla R fue presionada (para restart)\r\n     */\r\n    isRestartJustPressed(): boolean {\r\n        return Phaser.Input.Keyboard.JustDown(this.restartKey);\r\n    }\r\n\r\n    /**\r\n     * Verifica si la tecla M fue presionada (para menú)\r\n     */\r\n    isMenuJustPressed(): boolean {\r\n        return Phaser.Input.Keyboard.JustDown(this.menuKey);\r\n    }\r\n\r\n    /**\r\n     * Verifica si la tecla C fue presionada (para continuar con power-up)\r\n     */\r\n    isContinueJustPressed(): boolean {\r\n        return Phaser.Input.Keyboard.JustDown(this.continueKey);\r\n    }\r\n\r\n    /**\r\n     * Obtiene la dirección deseada actual\r\n     */\r\n    getDesiredDirection(): Direction {\r\n        return this.desiredDirection;\r\n    }\r\n\r\n    /**\r\n     * Resetea la dirección deseada\r\n     */\r\n    resetDesiredDirection(): void {\r\n        this.desiredDirection = { dx: 0, dy: 0 };\r\n    }\r\n\r\n    /**\r\n     * Limpieza de recursos\r\n     */\r\n    destroy(): void {\r\n        this.scene.input.keyboard?.off('keydown');\r\n        this.scene.input.off('pointerdown');\r\n        this.scene.input.off('pointerup');\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\n\r\n/**\r\n * Gestor de audio para música de fondo con playlist\r\n */\r\nexport class AudioManager {\r\n    private scene: Phaser.Scene;\r\n    private availableMusicKeys: string[] = [];\r\n    private backgroundMusic: Phaser.Sound.BaseSound | null = null;\r\n    private musicPlaylistOrder: string[] = [];\r\n    private currentPlaylistIndex: number = 0;\r\n\r\n    constructor(scene: Phaser.Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Detecta y carga archivos de música en preload\r\n     */\r\n    detectAndLoadMusic(): void {\r\n        this.availableMusicKeys = [];\r\n        const maxTracks = CONFIG.AUDIO.MAX_BG_TRACKS;\r\n\r\n        // Setup error handling\r\n        this.scene.load.on('loaderror', (file: Phaser.Loader.File) => {\r\n            if (file.key.startsWith('backgroundMusic')) {\r\n                const keyIndex = this.availableMusicKeys.indexOf(file.key);\r\n                if (keyIndex > -1) {\r\n                    this.availableMusicKeys.splice(keyIndex, 1);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.scene.load.on('filecomplete', (key: string) => {\r\n            if (key.startsWith('backgroundMusic')) {\r\n                if (!this.availableMusicKeys.includes(key)) {\r\n                    this.availableMusicKeys.push(key);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Queue music files for loading\r\n        for (let i = 1; i <= maxTracks; i++) {\r\n            const paddedNumber = i.toString().padStart(3, '0');\r\n            const filename = `bg_${paddedNumber}.mp3`;\r\n            const key = `backgroundMusic${i - 1}`;\r\n\r\n            try {\r\n                this.scene.load.audio(key, `sound/bg/${filename}`);\r\n            } catch (error) {\r\n                console.warn('Could not queue music file:', filename, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inicializa y comienza la reproducción de música\r\n     */\r\n    initMusic(): void {\r\n        const tryStartMusic = () => {\r\n            if (this.availableMusicKeys.length > 0) {\r\n                this.shufflePlaylist();\r\n                this.playNext();\r\n            } else {\r\n                this.scene.time.delayedCall(500, () => {\r\n                    if (this.availableMusicKeys.length > 0) {\r\n                        this.shufflePlaylist();\r\n                        this.playNext();\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        if (this.scene.sound.locked) {\r\n            this.scene.input.once('pointerdown', () => this.scene.sound.unlock());\r\n            if (this.scene.input.keyboard) {\r\n                this.scene.input.keyboard.once('keydown', () => this.scene.sound.unlock());\r\n            }\r\n            this.scene.sound.once('unlocked', tryStartMusic);\r\n        } else {\r\n            this.scene.time.delayedCall(200, tryStartMusic);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mezcla el orden de reproducción\r\n     */\r\n    shufflePlaylist(): void {\r\n        if (this.availableMusicKeys.length === 0) {\r\n            this.musicPlaylistOrder = [];\r\n            this.currentPlaylistIndex = 0;\r\n            return;\r\n        }\r\n\r\n        this.musicPlaylistOrder = [...this.availableMusicKeys];\r\n        for (let i = this.musicPlaylistOrder.length - 1; i > 0; i--) {\r\n            const j = Math.floor(Math.random() * (i + 1));\r\n            [this.musicPlaylistOrder[i], this.musicPlaylistOrder[j]] =\r\n                [this.musicPlaylistOrder[j], this.musicPlaylistOrder[i]];\r\n        }\r\n        this.currentPlaylistIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Reproduce la siguiente canción en la playlist\r\n     */\r\n    playNext(): void {\r\n        if (this.availableMusicKeys.length === 0) return;\r\n\r\n        this.stop();\r\n\r\n        if (this.currentPlaylistIndex >= this.musicPlaylistOrder.length) {\r\n            this.shufflePlaylist();\r\n        }\r\n\r\n        const musicKey = this.musicPlaylistOrder[this.currentPlaylistIndex];\r\n        this.currentPlaylistIndex++;\r\n\r\n        this.playSpecific(musicKey);\r\n    }\r\n\r\n    /**\r\n     * Reproduce la canción anterior\r\n     */\r\n    playPrevious(): void {\r\n        if (this.availableMusicKeys.length === 0) return;\r\n        this.currentPlaylistIndex = Math.max(0, this.currentPlaylistIndex - 2);\r\n        this.playNext();\r\n    }\r\n\r\n    /**\r\n     * Reproduce una canción específica\r\n     */\r\n    private playSpecific(musicKey: string): void {\r\n        try {\r\n            if (!this.scene.cache.audio.exists(musicKey)) return;\r\n\r\n            this.backgroundMusic = this.scene.sound.add(musicKey, {\r\n                loop: false,\r\n                volume: CONFIG.AUDIO.DEFAULT_VOLUME\r\n            });\r\n\r\n            this.backgroundMusic.play();\r\n            this.backgroundMusic.once('complete', () => {\r\n                this.playNext();\r\n            });\r\n\r\n            this.updateToggleButton(true);\r\n        } catch (error) {\r\n            console.error('Error in playSpecific:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pausa/Reanuda la música\r\n     */\r\n    togglePlayPause(): void {\r\n        const soundManager = this.scene.sound as Phaser.Sound.WebAudioSoundManager;\r\n        if (soundManager?.context?.state === 'suspended') {\r\n            soundManager.context.resume().catch(() => { });\r\n        }\r\n\r\n        if (this.backgroundMusic?.isPlaying) {\r\n            this.backgroundMusic.pause();\r\n            this.updateToggleButton(false);\r\n        } else if (this.backgroundMusic) {\r\n            this.backgroundMusic.resume();\r\n            this.updateToggleButton(true);\r\n        } else {\r\n            this.playNext();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detiene la música actual\r\n     */\r\n    stop(): void {\r\n        if (this.backgroundMusic) {\r\n            this.backgroundMusic.stop();\r\n            this.backgroundMusic.destroy();\r\n            this.backgroundMusic = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Establece el volumen\r\n     */\r\n    setVolume(volume: number): void {\r\n        if (this.backgroundMusic && 'setVolume' in this.backgroundMusic) {\r\n            (this.backgroundMusic as Phaser.Sound.WebAudioSound).setVolume(volume);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifica si hay música reproduciéndose\r\n     */\r\n    isPlaying(): boolean {\r\n        return this.backgroundMusic?.isPlaying ?? false;\r\n    }\r\n\r\n    /**\r\n     * Actualiza el texto del botón de toggle\r\n     */\r\n    private updateToggleButton(isPlaying: boolean): void {\r\n        const toggleButton = document.getElementById('toggle-music');\r\n        if (toggleButton) {\r\n            toggleButton.textContent = isPlaying ? 'Música Off' : 'Música On';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Limpieza de recursos\r\n     */\r\n    destroy(): void {\r\n        this.stop();\r\n        this.scene.load.off('loaderror');\r\n        this.scene.load.off('filecomplete');\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport type { Position } from '../types/game.types';\r\n\r\n/**\r\n * Calcula la escala óptima para un sprite basado en el tamaño de celda\r\n * @param textureKey - Clave de la textura en Phaser\r\n * @param targetSize - Tamaño objetivo (generalmente cellSize)\r\n * @param scene - Escena de Phaser para acceder a texturas\r\n * @returns Factor de escala calculado\r\n */\r\nexport function calculateSpriteScale(\r\n    textureKey: string,\r\n    targetSize: number,\r\n    scene: Phaser.Scene\r\n): number {\r\n    try {\r\n        if (!scene || !scene.textures || !scene.textures.get(textureKey)) {\r\n            console.warn(`calculateSpriteScale: Invalid texture key \"${textureKey}\"`);\r\n            return 1;\r\n        }\r\n\r\n        const texture = scene.textures.get(textureKey);\r\n        const sourceImage = texture.getSourceImage() as HTMLImageElement;\r\n        const originalWidth = sourceImage.width;\r\n        const originalHeight = sourceImage.height;\r\n\r\n        return Math.min(targetSize / originalWidth, targetSize / originalHeight);\r\n    } catch (error) {\r\n        console.error('Error calculating sprite scale:', error);\r\n        return 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Genera una posición aleatoria libre en el tablero\r\n * @param excludePositions - Array de posiciones a excluir\r\n * @param boardSize - Tamaño del tablero\r\n * @returns Posición libre o null si no se encuentra\r\n */\r\nexport function generateFreePosition(\r\n    excludePositions: Position[] = [],\r\n    boardSize: number\r\n): Position | null {\r\n    if (!Array.isArray(excludePositions)) {\r\n        console.warn('generateFreePosition: excludePositions must be an array');\r\n        excludePositions = [];\r\n    }\r\n\r\n    if (!boardSize || boardSize < 1) {\r\n        console.error('generateFreePosition: Invalid boardSize:', boardSize);\r\n        return null;\r\n    }\r\n\r\n    const maxAttempts = 50;\r\n    let attempts = 0;\r\n\r\n    while (attempts < maxAttempts) {\r\n        const position: Position = {\r\n            x: Math.floor(Math.random() * boardSize),\r\n            y: Math.floor(Math.random() * boardSize)\r\n        };\r\n\r\n        const isOccupied = excludePositions.some(\r\n            pos => pos.x === position.x && pos.y === position.y\r\n        );\r\n\r\n        if (!isOccupied) {\r\n            return position;\r\n        }\r\n\r\n        attempts++;\r\n    }\r\n\r\n    console.warn('generateFreePosition: Could not find free position after', maxAttempts, 'attempts');\r\n    return null;\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale } from '../utils/Utils';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { Position, Direction } from '../types/game.types';\r\n\r\n/**\r\n * Controlador del jugador con movimiento tipo sliding puzzle\r\n * Soporta cambio de dirección durante el movimiento (turn opportunity)\r\n */\r\nexport class PlayerController {\r\n    private scene: Phaser.Scene;\r\n    private collision: CollisionSystem;\r\n    private cellSize: number;\r\n    private playerPosition: Position = { x: 0, y: 0 };\r\n    private moveDirection: Direction = { dx: 0, dy: 0 };\r\n    private isMoving: boolean = false;\r\n    private playerMoveTween: Phaser.Tweens.Tween | null = null;\r\n\r\n    // Sprites\r\n    private playerSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private playerDieSprite: Phaser.GameObjects.Sprite | null = null;\r\n\r\n    // Particles\r\n    private coinParticles: Phaser.GameObjects.Particles.ParticleEmitter | null = null;\r\n    private trailParticles: Phaser.GameObjects.Particles.ParticleEmitter | null = null;\r\n\r\n    // Callbacks for turn opportunity\r\n    private getDesiredDirection: (() => Direction) | null = null;\r\n    private onTurnMove: ((dx: number, dy: number) => void) | null = null;\r\n\r\n    // Callback for processing items during movement\r\n    private currentStepCallback: ((x: number, y: number) => void) | null = null;\r\n\r\n    constructor(scene: Phaser.Scene, collision: CollisionSystem, cellSize: number) {\r\n        this.scene = scene;\r\n        this.collision = collision;\r\n        this.cellSize = cellSize;\r\n    }\r\n\r\n    /**\r\n     * Configura los callbacks para el cambio de dirección durante movimiento\r\n     */\r\n    setTurnCallbacks(\r\n        getDesiredDirection: () => Direction,\r\n        onTurnMove: (dx: number, dy: number) => void\r\n    ): void {\r\n        this.getDesiredDirection = getDesiredDirection;\r\n        this.onTurnMove = onTurnMove;\r\n    }\r\n\r\n    /**\r\n     * Crea el sprite del jugador y partículas\r\n     */\r\n    create(position: Position): void {\r\n        this.playerPosition = { ...position };\r\n\r\n        this.playerSprite = this.scene.add.sprite(\r\n            position.x * this.cellSize + this.cellSize / 2,\r\n            position.y * this.cellSize + this.cellSize / 2,\r\n            'player_stand'\r\n        );\r\n        this.playerSprite.setDepth(10);\r\n        this.adjustScaleAndRotation();\r\n\r\n        // Coin particles\r\n        this.coinParticles = this.scene.add.particles(0, 0, 'coin', {\r\n            speed: { min: 50, max: 150 },\r\n            scale: { start: 0.4, end: 0 },\r\n            lifespan: 600,\r\n            blendMode: 'ADD',\r\n            quantity: 10,\r\n            emitting: false\r\n        });\r\n\r\n        // Trail particles\r\n        this.trailParticles = this.scene.add.particles(0, 0, 'player_run', {\r\n            speed: 0,\r\n            scale: { start: calculateSpriteScale('player_run', this.cellSize, this.scene) * 0.9, end: 0.7 },\r\n            alpha: { start: 0.15, end: 0 },\r\n            lifespan: 1000,\r\n            blendMode: 'ADD',\r\n            frequency: 140,\r\n            emitting: false\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Mueve al jugador en una dirección hasta encontrar un obstáculo\r\n     */\r\n    move(\r\n        dx: number,\r\n        dy: number,\r\n        level: number,\r\n        traps: Position[],\r\n        exitPosition: Position,\r\n        checkEnemyCollision: (x: number, y: number) => boolean,\r\n        onStepCallback: (x: number, y: number) => void\r\n    ): void {\r\n        if (this.isMoving || (dx === 0 && dy === 0)) return;\r\n\r\n        this.moveDirection = { dx, dy };\r\n        const moveResult = this.collision.calculateMoveUntilObstacle(\r\n            this.playerPosition.x,\r\n            this.playerPosition.y,\r\n            dx, dy\r\n        );\r\n\r\n        if (moveResult.distance === 0) {\r\n            this.resetMovementState();\r\n            return;\r\n        }\r\n\r\n        this.startMovement();\r\n        this.currentStepCallback = onStepCallback;\r\n        const baseStepDuration = this.calculateStepDuration(level);\r\n        const finalDestination = this.calculateFinalDestination(\r\n            dx, dy, moveResult, traps, exitPosition, checkEnemyCollision\r\n        );\r\n\r\n        this.executeMovementTween(dx, dy, baseStepDuration, finalDestination, traps, exitPosition, checkEnemyCollision, onStepCallback);\r\n    }\r\n\r\n    /**\r\n     * Calcula la duración de cada paso basado en el nivel\r\n     */\r\n    private calculateStepDuration(level: number): number {\r\n        return Math.max(\r\n            CONFIG.PERFORMANCE.PLAYER_MIN_STEP_DURATION_MS,\r\n            CONFIG.PERFORMANCE.PLAYER_BASE_DURATION_MS - level * CONFIG.PERFORMANCE.PLAYER_STEP_DEC_PER_LEVEL\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Calcula el destino final considerando trampas, enemigos y salida\r\n     */\r\n    private calculateFinalDestination(\r\n        dx: number,\r\n        dy: number,\r\n        moveResult: { x: number; y: number; distance: number },\r\n        traps: Position[],\r\n        exitPosition: Position,\r\n        checkEnemyCollision: (x: number, y: number) => boolean\r\n    ): { x: number; y: number; step: number } {\r\n        const startX = this.playerPosition.x;\r\n        const startY = this.playerPosition.y;\r\n\r\n        for (let i = 1; i <= moveResult.distance; i++) {\r\n            const checkX = startX + (dx * i);\r\n            const checkY = startY + (dy * i);\r\n\r\n            if (this.collision.isTrap(checkX, checkY, traps)) {\r\n                return { x: checkX, y: checkY, step: i };\r\n            }\r\n            if (checkEnemyCollision(checkX, checkY)) {\r\n                return { x: checkX, y: checkY, step: i };\r\n            }\r\n            if (checkX === exitPosition.x && checkY === exitPosition.y) {\r\n                return { x: checkX, y: checkY, step: i };\r\n            }\r\n        }\r\n\r\n        return { x: moveResult.x, y: moveResult.y, step: moveResult.distance };\r\n    }\r\n\r\n    /**\r\n     * Ejecuta el tween de movimiento\r\n     */\r\n    private executeMovementTween(\r\n        dx: number,\r\n        dy: number,\r\n        baseStepDuration: number,\r\n        finalDestination: { x: number; y: number; step: number },\r\n        traps: Position[],\r\n        exitPosition: Position,\r\n        checkEnemyCollision: (x: number, y: number) => boolean,\r\n        onStepCallback: (x: number, y: number) => void\r\n    ): void {\r\n        const startX = this.playerPosition.x;\r\n        const startY = this.playerPosition.y;\r\n        let lastStepProcessed = -1;\r\n\r\n        this.playerMoveTween = this.scene.tweens.add({\r\n            targets: this.playerSprite,\r\n            x: finalDestination.x * this.cellSize + this.cellSize / 2,\r\n            y: finalDestination.y * this.cellSize + this.cellSize / 2,\r\n            duration: baseStepDuration * finalDestination.step,\r\n            ease: 'Linear',\r\n            onUpdate: (tween) => {\r\n                const progress = tween.progress;\r\n                const currentStep = Math.floor(progress * finalDestination.step);\r\n                const stepStart = Math.max(0, lastStepProcessed + 1);\r\n\r\n                for (let step = stepStart; step <= currentStep; step++) {\r\n                    const newX = startX + (dx * step);\r\n                    const newY = startY + (dy * step);\r\n\r\n                    if (newX !== this.playerPosition.x || newY !== this.playerPosition.y) {\r\n                        this.playerPosition.x = newX;\r\n                        this.playerPosition.y = newY;\r\n                        onStepCallback(newX, newY);\r\n\r\n                        // Check death conditions\r\n                        if (this.collision.isTrap(newX, newY, traps) ||\r\n                            checkEnemyCollision(newX, newY)) {\r\n                            // Emit event - GameScene.handleDeath() will use shield or set gameOver\r\n                            this.scene.events.emit('player:died');\r\n                            // After event, check if game is over (shield wasn't available)\r\n                            // If shield absorbed, continue movement with flash effect\r\n                            // Access gameState via scene's registry or event result\r\n                            const gameState = (this.scene as any).gameState;\r\n                            if (gameState?.isGameOver) {\r\n                                return; // Real death - stop movement\r\n                            }\r\n                            // Shield absorbed - continue movement (flash already triggered in handleDeath)\r\n                        }\r\n\r\n                        // Check exit\r\n                        if (newX === exitPosition.x && newY === exitPosition.y) {\r\n                            this.scene.events.emit('player:reachedExit');\r\n                            return;\r\n                        }\r\n\r\n                        // Check for turn opportunity (original logic)\r\n                        if (this.checkTurnOpportunity(tween)) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                lastStepProcessed = currentStep;\r\n            },\r\n            onComplete: () => {\r\n                this.onMovementComplete(finalDestination, traps, exitPosition);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si el jugador puede girar en la posición actual\r\n     * Esta es la lógica original que permite cambiar de dirección durante el movimiento\r\n     */\r\n    private checkTurnOpportunity(tween: Phaser.Tweens.Tween): boolean {\r\n        if (!this.getDesiredDirection || !this.onTurnMove) return false;\r\n\r\n        const desiredDirection = this.getDesiredDirection();\r\n\r\n        // Check if there's a desired direction different from current move direction\r\n        if ((desiredDirection.dx !== 0 || desiredDirection.dy !== 0) &&\r\n            (desiredDirection.dx !== this.moveDirection.dx ||\r\n                desiredDirection.dy !== this.moveDirection.dy)) {\r\n\r\n            const turnNextX = this.playerPosition.x + desiredDirection.dx;\r\n            const turnNextY = this.playerPosition.y + desiredDirection.dy;\r\n\r\n            // If turn direction is not blocked, execute turn\r\n            if (!this.collision.isCollision(turnNextX, turnNextY)) {\r\n                // Snap sprite to current grid position\r\n                this.playerSprite?.setPosition(\r\n                    this.playerPosition.x * this.cellSize + this.cellSize / 2,\r\n                    this.playerPosition.y * this.cellSize + this.cellSize / 2\r\n                );\r\n\r\n                // Stop current movement\r\n                tween.stop();\r\n                this.isMoving = false;\r\n\r\n                // Trigger new movement in desired direction\r\n                this.onTurnMove(desiredDirection.dx, desiredDirection.dy);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Finaliza el movimiento\r\n     */\r\n    private onMovementComplete(\r\n        finalDestination: { x: number; y: number; step: number },\r\n        traps: Position[],\r\n        exitPosition: Position\r\n    ): void {\r\n        if (this.trailParticles) this.trailParticles.stop();\r\n\r\n        this.playerPosition.x = finalDestination.x;\r\n        this.playerPosition.y = finalDestination.y;\r\n\r\n        if (finalDestination.step > 0) {\r\n            this.scene.cameras.main.shake(100, 0.005);\r\n        }\r\n\r\n        // Process items at final position (coins, power-ups)\r\n        if (this.currentStepCallback) {\r\n            this.currentStepCallback(this.playerPosition.x, this.playerPosition.y);\r\n        }\r\n\r\n        // Check trap at final position\r\n        if (this.collision.isTrap(this.playerPosition.x, this.playerPosition.y, traps)) {\r\n            this.scene.events.emit('player:died');\r\n            // Check if game is over (shield wasn't available)\r\n            const gameState = (this.scene as any).gameState;\r\n            if (gameState?.isGameOver) {\r\n                return; // Real death\r\n            }\r\n            // Shield absorbed - continue to reset movement state\r\n        }\r\n\r\n        if (this.playerPosition.x === exitPosition.x &&\r\n            this.playerPosition.y === exitPosition.y) {\r\n            this.scene.events.emit('player:reachedExit');\r\n            return;\r\n        }\r\n\r\n        this.isMoving = false;\r\n        this.playerMoveTween = null;\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n        this.playerSprite?.setTexture('player_stand');\r\n        this.adjustScaleAndRotation();\r\n    }\r\n\r\n    /**\r\n     * Inicia el estado de movimiento\r\n     */\r\n    private startMovement(): void {\r\n        this.isMoving = true;\r\n        this.playerSprite?.setTexture('player_run');\r\n        this.adjustScaleAndRotation();\r\n\r\n        if (this.trailParticles && this.playerSprite) {\r\n            this.trailParticles.start();\r\n            this.trailParticles.startFollow(this.playerSprite);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resetea el estado de movimiento\r\n     */\r\n    private resetMovementState(): void {\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n        this.playerSprite?.setTexture('player_stand');\r\n        this.adjustScaleAndRotation();\r\n    }\r\n\r\n    /**\r\n     * Ajusta la escala y rotación del sprite según la dirección\r\n     */\r\n    private adjustScaleAndRotation(): void {\r\n        if (!this.playerSprite) return;\r\n\r\n        const playerScale = calculateSpriteScale(this.playerSprite.texture.key, this.cellSize, this.scene);\r\n        this.playerSprite.setScale(playerScale);\r\n\r\n        if (this.moveDirection.dx === 1) {\r\n            this.playerSprite.setAngle(0);\r\n            this.playerSprite.setFlipX(false);\r\n        } else if (this.moveDirection.dx === -1) {\r\n            this.playerSprite.setAngle(0);\r\n            this.playerSprite.setFlipX(true);\r\n        } else if (this.moveDirection.dy === -1) {\r\n            this.playerSprite.setAngle(-90);\r\n            this.playerSprite.setFlipX(false);\r\n        } else if (this.moveDirection.dy === 1) {\r\n            this.playerSprite.setAngle(90);\r\n            this.playerSprite.setFlipX(false);\r\n        } else {\r\n            // Default orientation (facing right)\r\n            this.playerSprite.setAngle(0);\r\n            this.playerSprite.setFlipX(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emite partículas de moneda recogida\r\n     */\r\n    emitCoinParticles(x: number, y: number): void {\r\n        if (this.coinParticles) {\r\n            this.coinParticles.emitParticleAt(\r\n                x * this.cellSize + this.cellSize / 2,\r\n                y * this.cellSize + this.cellSize / 2\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Efecto de parpadeo cuando el shield absorbe un golpe\r\n     * Lucy sigue moviéndose pero parpadea brevemente\r\n     */\r\n    flashInvincibility(): void {\r\n        if (!this.playerSprite) return;\r\n\r\n        // Blink effect with tint\r\n        this.scene.tweens.add({\r\n            targets: this.playerSprite,\r\n            alpha: { from: 1, to: 0.3 },\r\n            duration: 80,\r\n            yoyo: true,\r\n            repeat: 4,\r\n            onComplete: () => {\r\n                this.playerSprite?.setAlpha(1);\r\n            }\r\n        });\r\n\r\n        // Blue tint flash\r\n        this.playerSprite.setTint(0x00bfff);\r\n        this.scene.time.delayedCall(400, () => {\r\n            this.playerSprite?.clearTint();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Muestra el sprite de muerte\r\n     */\r\n    showDeathSprite(): void {\r\n        if (this.playerSprite) {\r\n            this.playerSprite.destroy();\r\n            this.playerSprite = null;\r\n        }\r\n\r\n        this.playerDieSprite = this.scene.add.sprite(\r\n            this.playerPosition.x * this.cellSize + this.cellSize / 2,\r\n            this.playerPosition.y * this.cellSize + this.cellSize / 2,\r\n            'player_die'\r\n        );\r\n        const dieScale = calculateSpriteScale('player_die', this.cellSize, this.scene);\r\n        this.playerDieSprite.setScale(dieScale);\r\n    }\r\n\r\n    /**\r\n     * Detiene el movimiento actual\r\n     */\r\n    stopMovement(): void {\r\n        if (this.playerMoveTween) {\r\n            this.playerMoveTween.stop();\r\n            this.playerMoveTween = null;\r\n        }\r\n        this.isMoving = false;\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n        if (this.trailParticles) this.trailParticles.stop();\r\n    }\r\n\r\n    /**\r\n     * Resetea el jugador a una posición\r\n     */\r\n    reset(position: Position): void {\r\n        this.playerPosition = { ...position };\r\n        this.isMoving = false;\r\n        this.moveDirection = { dx: 0, dy: 0 };\r\n\r\n        if (this.playerMoveTween) {\r\n            this.playerMoveTween.stop();\r\n            this.playerMoveTween = null;\r\n        }\r\n\r\n        if (this.playerDieSprite) {\r\n            this.playerDieSprite.destroy();\r\n            this.playerDieSprite = null;\r\n        }\r\n\r\n        // Recreate player sprite if needed\r\n        if (!this.playerSprite) {\r\n            this.playerSprite = this.scene.add.sprite(\r\n                position.x * this.cellSize + this.cellSize / 2,\r\n                position.y * this.cellSize + this.cellSize / 2,\r\n                'player_stand'\r\n            );\r\n            this.playerSprite.setDepth(10);\r\n        } else {\r\n            this.playerSprite.setPosition(\r\n                position.x * this.cellSize + this.cellSize / 2,\r\n                position.y * this.cellSize + this.cellSize / 2\r\n            );\r\n            this.playerSprite.setVisible(true);\r\n            this.playerSprite.setTexture('player_stand');\r\n        }\r\n\r\n        this.adjustScaleAndRotation();\r\n    }\r\n\r\n    /**\r\n     * Obtiene la posición actual del jugador\r\n     */\r\n    getPosition(): Position {\r\n        return { ...this.playerPosition };\r\n    }\r\n\r\n    /**\r\n     * Obtiene la dirección actual de movimiento\r\n     */\r\n    getMoveDirection(): Direction {\r\n        return { ...this.moveDirection };\r\n    }\r\n\r\n    /**\r\n     * Verifica si el jugador está en movimiento\r\n     */\r\n    getIsMoving(): boolean {\r\n        return this.isMoving;\r\n    }\r\n\r\n    /**\r\n     * Obtiene el sprite del jugador\r\n     */\r\n    getSprite(): Phaser.GameObjects.Sprite | null {\r\n        return this.playerSprite;\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.stopMovement();\r\n        if (this.playerSprite) this.playerSprite.destroy();\r\n        if (this.playerDieSprite) this.playerDieSprite.destroy();\r\n        if (this.coinParticles) this.coinParticles.destroy();\r\n        if (this.trailParticles) this.trailParticles.destroy();\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale, generateFreePosition } from '../utils/Utils';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { Position, Direction, Enemy } from '../types/game.types';\r\n\r\n/**\r\n * Gestor de enemigos regulares con movimiento aleatorio\r\n * Soporta colisión entre enemigos\r\n */\r\nexport class EnemyManager {\r\n    private scene: Phaser.Scene;\r\n    private collision: CollisionSystem;\r\n    private enemies: Enemy[] = [];\r\n    private cellSize: number;\r\n\r\n    constructor(scene: Phaser.Scene, collision: CollisionSystem, cellSize: number) {\r\n        this.scene = scene;\r\n        this.collision = collision;\r\n        this.cellSize = cellSize;\r\n    }\r\n\r\n    /**\r\n     * Inicializa los enemigos según el nivel\r\n     * - Primer enemigo aparece en nivel 5\r\n     * - Segundo enemigo aparece cada 7 niveles (5, 12, 19, 26...)\r\n     */\r\n    init(level: number, excludePositions: Position[]): void {\r\n        this.reset();\r\n\r\n        // Los enemigos solo aparecen desde el nivel configurado\r\n        if (level < CONFIG.ENEMIES.FIRST_SPAWN_LEVEL) return;\r\n\r\n        // Calcular cantidad de enemigos: 1 base + 1 adicional cada SECOND_ENEMY_INTERVAL niveles\r\n        let enemyCount = 1;\r\n        const secondEnemyLevel = CONFIG.ENEMIES.FIRST_SPAWN_LEVEL + CONFIG.ENEMIES.SECOND_ENEMY_INTERVAL;\r\n        if (level >= secondEnemyLevel) {\r\n            enemyCount = 1 + Math.floor((level - CONFIG.ENEMIES.FIRST_SPAWN_LEVEL) / CONFIG.ENEMIES.SECOND_ENEMY_INTERVAL);\r\n        }\r\n        // Cap máximo de enemigos\r\n        enemyCount = Math.min(enemyCount, CONFIG.ENEMIES.MAX_COUNT);\r\n\r\n        const boardSize = this.collision.getBoardSize();\r\n\r\n        for (let i = 0; i < enemyCount; i++) {\r\n            const allExcluded = [...excludePositions, ...this.enemies.map(e => ({ x: e.x, y: e.y }))];\r\n            const position = generateFreePosition(allExcluded, boardSize);\r\n\r\n            if (!position) continue;\r\n\r\n            const enemy: Enemy = {\r\n                x: position.x,\r\n                y: position.y,\r\n                direction: this.getRandomDirection(),\r\n                moving: false,\r\n                sprite: null\r\n            };\r\n\r\n            enemy.sprite = this.scene.add.sprite(\r\n                enemy.x * this.cellSize + this.cellSize / 2,\r\n                enemy.y * this.cellSize + this.cellSize / 2,\r\n                'enemy'\r\n            );\r\n\r\n            const enemyScale = calculateSpriteScale('enemy', this.cellSize, this.scene);\r\n            enemy.sprite.setScale(enemyScale);\r\n            enemy.sprite.setFlipX(enemy.direction.dx === -1);\r\n\r\n            this.enemies.push(enemy);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza el movimiento de todos los enemigos\r\n     * Incluye colisión entre enemigos\r\n     */\r\n    update(): void {\r\n        this.enemies.forEach((enemy, index) => {\r\n            if (!enemy?.sprite) return;\r\n\r\n            if (!enemy.moving) {\r\n                enemy.moving = true;\r\n                const nextX = enemy.x + enemy.direction.dx;\r\n                const nextY = enemy.y + enemy.direction.dy;\r\n\r\n                // Check wall collision\r\n                const wallCollision = this.collision.isCollision(nextX, nextY);\r\n\r\n                // Check collision with other enemies\r\n                const enemyCollision = this.checkEnemyAtPosition(nextX, nextY, index);\r\n\r\n                if (wallCollision || enemyCollision) {\r\n                    enemy.direction = this.getRandomDirection();\r\n                    enemy.moving = false;\r\n                    enemy.sprite.setFlipX(enemy.direction.dx === -1);\r\n                } else {\r\n                    this.scene.tweens.add({\r\n                        targets: enemy.sprite,\r\n                        x: nextX * this.cellSize + this.cellSize / 2,\r\n                        y: nextY * this.cellSize + this.cellSize / 2,\r\n                        duration: CONFIG.ENEMIES.MOVE_TWEEN_DURATION_MS,\r\n                        onComplete: () => {\r\n                            enemy.x = nextX;\r\n                            enemy.y = nextY;\r\n                            enemy.moving = false;\r\n\r\n                            // Emit collision check event\r\n                            this.scene.events.emit('enemy:moved', { x: enemy.x, y: enemy.y });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si hay otro enemigo en una posición (excluyendo el actual)\r\n     */\r\n    private checkEnemyAtPosition(x: number, y: number, excludeIndex: number): boolean {\r\n        return this.enemies.some((e, i) => {\r\n            if (i === excludeIndex) return false;\r\n            return Math.round(e.x) === x && Math.round(e.y) === y;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifica si el jugador colisiona con algún enemigo\r\n     */\r\n    checkCollision(playerX: number, playerY: number): boolean {\r\n        return this.enemies.some(\r\n            e => Math.round(e.x) === playerX && Math.round(e.y) === playerY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Obtiene una dirección aleatoria\r\n     */\r\n    private getRandomDirection(): Direction {\r\n        const directions: Direction[] = [\r\n            { dx: 0, dy: -1 },\r\n            { dx: 1, dy: 0 },\r\n            { dx: 0, dy: 1 },\r\n            { dx: -1, dy: 0 }\r\n        ];\r\n        return directions[Phaser.Math.Between(0, directions.length - 1)];\r\n    }\r\n\r\n    /**\r\n     * Obtiene los enemigos actuales\r\n     */\r\n    getEnemies(): Enemy[] {\r\n        return this.enemies;\r\n    }\r\n\r\n    /**\r\n     * Actualiza los sprites de enemigos (para flip direction)\r\n     */\r\n    updateSprites(): void {\r\n        this.enemies.forEach(enemy => {\r\n            if (enemy.sprite) {\r\n                if (enemy.direction.dx === -1) {\r\n                    enemy.sprite.setFlipX(true);\r\n                } else if (enemy.direction.dx === 1) {\r\n                    enemy.sprite.setFlipX(false);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resetea todos los enemigos\r\n     */\r\n    reset(): void {\r\n        this.enemies.forEach(enemy => {\r\n            if (enemy?.sprite) {\r\n                enemy.sprite.destroy();\r\n            }\r\n        });\r\n        this.enemies = [];\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.reset();\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale } from '../utils/Utils';\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport type { Position, Obstacle, Spider, SpiderState } from '../types/game.types';\r\n\r\n/**\r\n * Gestor de arañas con patrullaje entre dos puntos\r\n */\r\nexport class SpiderManager {\r\n    private scene: Phaser.Scene;\r\n    private collision: CollisionSystem;\r\n    private spiders: Spider[] = [];\r\n    private cellSize: number;\r\n    private boardSize: number;\r\n    private obstacles: Obstacle[] = [];\r\n\r\n    constructor(scene: Phaser.Scene, collision: CollisionSystem, cellSize: number, boardSize: number) {\r\n        this.scene = scene;\r\n        this.collision = collision;\r\n        this.cellSize = cellSize;\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Genera arañas según el nivel\r\n     */\r\n    generate(level: number, obstacles: Obstacle[], exitPosition: Position): void {\r\n        this.reset();\r\n        this.obstacles = obstacles;\r\n\r\n        if (!this.boardSize) return;\r\n\r\n        let spiderCount = 0;\r\n        // Spiders only appear from configured level\r\n        if (level < CONFIG.SPIDER.FIRST_SPAWN_LEVEL) {\r\n            spiderCount = 0;\r\n        } else if (level < CONFIG.SPIDER.SECOND_SPAWN_LEVEL) {\r\n            spiderCount = 1;\r\n        } else if (level < CONFIG.SPIDER.THIRD_SPAWN_LEVEL) {\r\n            spiderCount = 2;\r\n        } else {\r\n            spiderCount = 3;\r\n        }\r\n\r\n        if (spiderCount === 0) return;\r\n\r\n        for (let i = 0; i < spiderCount; i++) {\r\n            let attempts = 0;\r\n            let spiderAdded = false;\r\n\r\n            while (!spiderAdded && attempts < 50) {\r\n                attempts++;\r\n\r\n                const pointA = {\r\n                    x: Phaser.Math.Between(0, this.boardSize - 1),\r\n                    y: Phaser.Math.Between(0, this.boardSize - 1)\r\n                };\r\n\r\n                if (!this.isValidPoint(pointA, exitPosition)) continue;\r\n\r\n                const axis = Phaser.Math.Between(0, 1);\r\n                const pointB = { x: pointA.x, y: pointA.y };\r\n\r\n                if (axis === 0) {\r\n                    pointB.x = Phaser.Math.Between(0, this.boardSize - 1);\r\n                } else {\r\n                    pointB.y = Phaser.Math.Between(0, this.boardSize - 1);\r\n                }\r\n\r\n                const dist = Math.abs((pointB.x - pointA.x) + (pointB.y - pointA.y));\r\n                if (dist < CONFIG.SPIDER.MIN_PATROL_DISTANCE) continue;\r\n                if (!this.isValidPoint(pointB, exitPosition)) continue;\r\n                // Use centralized isPathClear from CollisionSystem\r\n                if (!this.collision.isPathClear(pointA, pointB, this.obstacles)) continue;\r\n\r\n                const spider: Spider = {\r\n                    state: 'WAITING' as SpiderState,\r\n                    pointA: { ...pointA },\r\n                    pointB: { ...pointB },\r\n                    currentTarget: { ...pointB },\r\n                    x: pointA.x,\r\n                    y: pointA.y,\r\n                    waitStartTime: this.scene.time.now,\r\n                    sprite: null\r\n                };\r\n\r\n                spider.sprite = this.scene.add.sprite(\r\n                    spider.x * this.cellSize + this.cellSize / 2,\r\n                    spider.y * this.cellSize + this.cellSize / 2,\r\n                    'spider'\r\n                );\r\n\r\n                const spiderScale = calculateSpriteScale('spider', this.cellSize, this.scene);\r\n                spider.sprite.setScale(spiderScale);\r\n\r\n                this.spiders.push(spider);\r\n                spiderAdded = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza el estado y movimiento de las arañas\r\n     */\r\n    update(time: number, playerPosition: Position): boolean {\r\n        let playerHit = false;\r\n\r\n        this.spiders.forEach(spider => {\r\n            if (!spider.sprite) return;\r\n\r\n            // Collision check\r\n            if (Math.round(spider.x) === playerPosition.x &&\r\n                Math.round(spider.y) === playerPosition.y) {\r\n                playerHit = true;\r\n            }\r\n\r\n            // State machine\r\n            if (spider.state === 'WAITING') {\r\n                if (time - spider.waitStartTime > CONFIG.SPIDER.WAIT_DURATION_MS) {\r\n                    spider.state = 'MOVING';\r\n                }\r\n            } else if (spider.state === 'MOVING') {\r\n                const dx = spider.currentTarget.x - spider.x;\r\n                const dy = spider.currentTarget.y - spider.y;\r\n                const speed = CONFIG.SPIDER.MOVE_SPEED;\r\n\r\n                if (Math.abs(dx) < speed && Math.abs(dy) < speed) {\r\n                    // Arrived at target\r\n                    spider.x = spider.currentTarget.x;\r\n                    spider.y = spider.currentTarget.y;\r\n                    spider.sprite.setPosition(\r\n                        spider.x * this.cellSize + this.cellSize / 2,\r\n                        spider.y * this.cellSize + this.cellSize / 2\r\n                    );\r\n\r\n                    spider.state = 'WAITING';\r\n                    spider.waitStartTime = time;\r\n\r\n                    // Toggle target\r\n                    if (spider.currentTarget.x === spider.pointA.x &&\r\n                        spider.currentTarget.y === spider.pointA.y) {\r\n                        spider.currentTarget = { ...spider.pointB };\r\n                    } else {\r\n                        spider.currentTarget = { ...spider.pointA };\r\n                    }\r\n                } else {\r\n                    // Move towards target\r\n                    spider.x += Math.sign(dx) * speed;\r\n                    spider.y += Math.sign(dy) * speed;\r\n\r\n                    spider.sprite.setPosition(\r\n                        spider.x * this.cellSize + this.cellSize / 2,\r\n                        spider.y * this.cellSize + this.cellSize / 2\r\n                    );\r\n                }\r\n            }\r\n        });\r\n\r\n        return playerHit;\r\n    }\r\n\r\n    /**\r\n     * Verifica si un punto es válido para la araña\r\n     */\r\n    private isValidPoint(p: Position, exitPosition: Position): boolean {\r\n        if (p.x < 0 || p.x >= this.boardSize || p.y < 0 || p.y >= this.boardSize) {\r\n            return false;\r\n        }\r\n        if (p.x === 0 && p.y === 0) return false; // Player start\r\n        if (p.x === exitPosition.x && p.y === exitPosition.y) return false;\r\n        if (this.obstacles.some(o => o.x === p.x && o.y === p.y)) return false;\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Verifica colisión del jugador con arañas\r\n     */\r\n    checkCollision(playerX: number, playerY: number): boolean {\r\n        return this.spiders.some(\r\n            s => Math.round(s.x) === playerX && Math.round(s.y) === playerY\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Obtiene las arañas actuales\r\n     */\r\n    getSpiders(): Spider[] {\r\n        return this.spiders;\r\n    }\r\n\r\n    /**\r\n     * Resetea todas las arañas\r\n     */\r\n    reset(): void {\r\n        this.spiders.forEach(spider => {\r\n            if (spider.sprite) {\r\n                spider.sprite.destroy();\r\n            }\r\n        });\r\n        this.spiders = [];\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.reset();\r\n    }\r\n}\r\n","import type { EventListenerEntry } from '../types/game.types';\r\n\r\n/**\r\n * Callbacks para eventos de UI\r\n */\r\nexport interface UICallbacks {\r\n    onMusicToggle: () => void;\r\n    onVolumeChange: (volume: number) => void;\r\n    onNextMusic: () => void;\r\n    onPrevMusic: () => void;\r\n    onRestart: () => void;\r\n}\r\n\r\n/**\r\n * Gestor de interfaz de usuario (elementos DOM)\r\n */\r\nexport class UIManager {\r\n    private eventListenerCleanup: EventListenerEntry[] = [];\r\n\r\n    constructor() { }\r\n\r\n    /**\r\n     * Actualiza el marcador de puntuación\r\n     */\r\n    updateScore(score: number): void {\r\n        const safeScore = (typeof score === 'number' && !isNaN(score)) ? score : 0;\r\n        const scoreElement = document.getElementById('score');\r\n        if (scoreElement) {\r\n            scoreElement.textContent = 'Puntos: ' + safeScore;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza el indicador de nivel\r\n     */\r\n    updateLevel(level: number): void {\r\n        const safeLevel = (typeof level === 'number' && !isNaN(level)) ? level : 1;\r\n        const levelElement = document.getElementById('level');\r\n        if (levelElement) {\r\n            levelElement.textContent = 'Nivel: ' + safeLevel;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza los contadores de power-ups\r\n     */\r\n    updatePowerUps(shields: number, continues: number): void {\r\n        const shieldsElement = document.getElementById('shields');\r\n        const continuesElement = document.getElementById('continues');\r\n\r\n        if (shieldsElement) {\r\n            shieldsElement.textContent = 'S: ' + shields;\r\n            shieldsElement.style.opacity = shields > 0 ? '1' : '0.4';\r\n        }\r\n        if (continuesElement) {\r\n            continuesElement.textContent = 'C: ' + continues;\r\n            continuesElement.style.opacity = continues > 0 ? '1' : '0.4';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza tanto puntuación como nivel\r\n     */\r\n    updateScoreAndLevel(score: number, level: number): void {\r\n        this.updateScore(score);\r\n        this.updateLevel(level);\r\n    }\r\n\r\n    /**\r\n     * Actualiza toda la UI (score, level, power-ups)\r\n     */\r\n    updateAll(score: number, level: number, shields: number, continues: number): void {\r\n        this.updateScore(score);\r\n        this.updateLevel(level);\r\n        this.updatePowerUps(shields, continues);\r\n    }\r\n\r\n    /**\r\n     * Configura los event listeners para los controles de UI\r\n     */\r\n    setupEventListeners(callbacks: UICallbacks): void {\r\n        // Cleanup old listeners\r\n        this.cleanup();\r\n\r\n        const toggleMusicButton = document.getElementById('toggle-music');\r\n        const volumeSlider = document.getElementById('volume-slider') as HTMLInputElement;\r\n        const nextButton = document.getElementById('next-music');\r\n        const prevButton = document.getElementById('prev-music');\r\n        const restartButton = document.getElementById('restart-button');\r\n\r\n        const addListener = (\r\n            element: HTMLElement | null,\r\n            event: string,\r\n            handler: EventListener\r\n        ): void => {\r\n            if (element) {\r\n                element.addEventListener(event, handler);\r\n                this.eventListenerCleanup.push({ element, event, handler });\r\n            }\r\n        };\r\n\r\n        addListener(toggleMusicButton, 'click', () => {\r\n            callbacks.onMusicToggle();\r\n        });\r\n\r\n        addListener(volumeSlider, 'input', (e: Event) => {\r\n            const target = e.target as HTMLInputElement;\r\n            callbacks.onVolumeChange(parseFloat(target.value));\r\n        });\r\n\r\n        addListener(nextButton, 'click', () => {\r\n            callbacks.onNextMusic();\r\n        });\r\n\r\n        addListener(prevButton, 'click', () => {\r\n            callbacks.onPrevMusic();\r\n        });\r\n\r\n        addListener(restartButton, 'click', () => {\r\n            callbacks.onRestart();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Limpia todos los event listeners\r\n     */\r\n    cleanup(): void {\r\n        this.eventListenerCleanup.forEach(({ element, event, handler }) => {\r\n            if (element) {\r\n                element.removeEventListener(event, handler);\r\n            }\r\n        });\r\n        this.eventListenerCleanup = [];\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.cleanup();\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { ScoreManager } from './ScoreManager';\r\n\r\n/**\r\n * Gestor del estado del juego (game over, score, level, power-ups)\r\n */\r\nexport class GameStateManager {\r\n    private scene: Phaser.Scene;\r\n    private _gameOver: boolean = false;\r\n    private _level: number = 1;\r\n    private _score: number = 0;\r\n    private _initialCoinCount: number = 0;\r\n\r\n    // Power-ups\r\n    private _shieldCount: number = 0;\r\n    private _continueCount: number = 0;\r\n\r\n    // Game Over UI\r\n    private gameOverText: Phaser.GameObjects.Text | null = null;\r\n    private restartText: Phaser.GameObjects.Text | null = null;\r\n    private continueText: Phaser.GameObjects.Text | null = null;\r\n    private newRecordText: Phaser.GameObjects.Text | null = null;\r\n    private menuText: Phaser.GameObjects.Text | null = null;\r\n\r\n    constructor(scene: Phaser.Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Crea los textos de UI del game over\r\n     */\r\n    createGameOverUI(): void {\r\n        this.gameOverText = this.scene.add.text(\r\n            CONFIG.GAME_WIDTH / 2,\r\n            CONFIG.GAME_HEIGHT / 2,\r\n            'GAME OVER',\r\n            {\r\n                fontSize: CONFIG.UI.GAME_OVER_FONT_SIZE,\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#ff0000',\r\n                stroke: '#ffffff',\r\n                strokeThickness: 4\r\n            }\r\n        );\r\n        this.gameOverText.setOrigin(0.5);\r\n        this.gameOverText.setDepth(100);\r\n        this.gameOverText.setVisible(false);\r\n\r\n        this.restartText = this.scene.add.text(\r\n            CONFIG.GAME_WIDTH / 2,\r\n            CONFIG.GAME_HEIGHT / 2 + CONFIG.UI.RESTART_OFFSET_Y,\r\n            'PRESS R TO RESTART',\r\n            {\r\n                fontSize: CONFIG.UI.RESTART_FONT_SIZE,\r\n                fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                color: '#ffff00',\r\n                align: 'center'\r\n            }\r\n        );\r\n        this.restartText.setOrigin(0.5);\r\n        this.restartText.setDepth(100);\r\n        this.restartText.setVisible(false);\r\n    }\r\n\r\n    /**\r\n     * Muestra la pantalla de game over\r\n     */\r\n    showGameOver(): void {\r\n        this._gameOver = true;\r\n        const isNewRecord = ScoreManager.setHighScore(this._score);\r\n\r\n        this.gameOverText?.setVisible(true);\r\n        this.restartText?.setVisible(true);\r\n\r\n        // Show continue option if player has continues\r\n        if (this._continueCount > 0) {\r\n            if (!this.continueText) {\r\n                this.continueText = this.scene.add.text(\r\n                    CONFIG.GAME_WIDTH / 2,\r\n                    CONFIG.GAME_HEIGHT / 2 + CONFIG.UI.RESTART_OFFSET_Y + 25,\r\n                    '',\r\n                    {\r\n                        fontSize: '14px',\r\n                        fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                        color: '#00ff00'\r\n                    }\r\n                );\r\n                this.continueText.setOrigin(0.5);\r\n                this.continueText.setDepth(100);\r\n            }\r\n            this.continueText.setText(`C PARA CONTINUAR (${this._continueCount}❤)`);\r\n            this.continueText.setVisible(true);\r\n        } else {\r\n            this.continueText?.setVisible(false);\r\n        }\r\n\r\n        if (isNewRecord && this._score > 0) {\r\n            if (!this.newRecordText) {\r\n                this.newRecordText = this.scene.add.text(\r\n                    CONFIG.GAME_WIDTH / 2,\r\n                    CONFIG.GAME_HEIGHT / 2 - 60,\r\n                    '¡NUEVO RÉCORD!',\r\n                    {\r\n                        fontSize: '20px',\r\n                        fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                        color: '#ffff00',\r\n                        stroke: '#ff6600',\r\n                        strokeThickness: 3\r\n                    }\r\n                );\r\n                this.newRecordText.setOrigin(0.5);\r\n                this.newRecordText.setDepth(100);\r\n            }\r\n            this.newRecordText.setVisible(true);\r\n\r\n            this.scene.tweens.add({\r\n                targets: this.newRecordText,\r\n                scaleX: 1.2,\r\n                scaleY: 1.2,\r\n                duration: 400,\r\n                yoyo: true,\r\n                repeat: -1\r\n            });\r\n        }\r\n\r\n        // Adjust menu text position based on whether continue is shown\r\n        const menuOffsetY = this._continueCount > 0\r\n            ? CONFIG.UI.RESTART_OFFSET_Y + 55\r\n            : CONFIG.UI.RESTART_OFFSET_Y + 30;\r\n\r\n        if (!this.menuText) {\r\n            this.menuText = this.scene.add.text(\r\n                CONFIG.GAME_WIDTH / 2,\r\n                CONFIG.GAME_HEIGHT / 2 + menuOffsetY,\r\n                'PRESIONA M PARA MENÚ',\r\n                {\r\n                    fontSize: '14px',\r\n                    fontFamily: CONFIG.UI.FONT_FAMILY,\r\n                    color: '#888888'\r\n                }\r\n            );\r\n            this.menuText.setOrigin(0.5);\r\n            this.menuText.setDepth(100);\r\n        } else {\r\n            this.menuText.setY(CONFIG.GAME_HEIGHT / 2 + menuOffsetY);\r\n        }\r\n        this.menuText.setVisible(true);\r\n    }\r\n\r\n    /**\r\n     * Oculta la UI de game over\r\n     */\r\n    hideGameOverUI(): void {\r\n        this.gameOverText?.setVisible(false);\r\n        this.restartText?.setVisible(false);\r\n        this.continueText?.setVisible(false);\r\n        this.newRecordText?.setVisible(false);\r\n        this.menuText?.setVisible(false);\r\n    }\r\n\r\n    /**\r\n     * Añade puntos al score\r\n     */\r\n    addScore(points: number): void {\r\n        this._score += points;\r\n    }\r\n\r\n    /**\r\n     * Avanza al siguiente nivel\r\n     */\r\n    nextLevel(): void {\r\n        this._score += 100;\r\n        this._level += 1;\r\n    }\r\n\r\n    // ========== POWER-UPS ==========\r\n\r\n    /**\r\n     * Añade un shield\r\n     */\r\n    addShield(): void {\r\n        this._shieldCount++;\r\n    }\r\n\r\n    /**\r\n     * Consume un shield si está disponible\r\n     * @returns true si se consumió, false si no había\r\n     */\r\n    useShield(): boolean {\r\n        if (this._shieldCount > 0) {\r\n            this._shieldCount--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Añade un continue\r\n     */\r\n    addContinue(): void {\r\n        this._continueCount++;\r\n    }\r\n\r\n    /**\r\n     * Consume un continue si está disponible\r\n     * @returns true si se consumió, false si no había\r\n     */\r\n    useContinue(): boolean {\r\n        if (this._continueCount > 0) {\r\n            this._continueCount--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Verifica si tiene shield disponible\r\n     */\r\n    hasShield(): boolean {\r\n        return this._shieldCount > 0;\r\n    }\r\n\r\n    /**\r\n     * Verifica si tiene continue disponible\r\n     */\r\n    hasContinue(): boolean {\r\n        return this._continueCount > 0;\r\n    }\r\n\r\n    // ========== RESET ==========\r\n\r\n    /**\r\n     * Resetea el estado del juego\r\n     */\r\n    reset(fullReset: boolean): void {\r\n        if (fullReset) {\r\n            this._level = 1;\r\n            this._score = 0;\r\n            this._shieldCount = 0;\r\n            this._continueCount = 0;\r\n        }\r\n        this._gameOver = false;\r\n        this.hideGameOverUI();\r\n    }\r\n\r\n    /**\r\n     * Retorna al menú principal\r\n     */\r\n    returnToMenu(): void {\r\n        this.scene.cameras.main.fadeOut(300, 0, 0, 0);\r\n        this.scene.time.delayedCall(300, () => {\r\n            this.scene.scene.start('MenuScene');\r\n        });\r\n    }\r\n\r\n    // ========== GETTERS/SETTERS ==========\r\n\r\n    get isGameOver(): boolean {\r\n        return this._gameOver;\r\n    }\r\n\r\n    set isGameOver(value: boolean) {\r\n        this._gameOver = value;\r\n    }\r\n\r\n    get level(): number {\r\n        return this._level;\r\n    }\r\n\r\n    get score(): number {\r\n        return this._score;\r\n    }\r\n\r\n    get shieldCount(): number {\r\n        return this._shieldCount;\r\n    }\r\n\r\n    get continueCount(): number {\r\n        return this._continueCount;\r\n    }\r\n\r\n    get initialCoinCount(): number {\r\n        return this._initialCoinCount;\r\n    }\r\n\r\n    set initialCoinCount(value: number) {\r\n        this._initialCoinCount = value;\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        if (this.gameOverText) this.gameOverText.destroy();\r\n        if (this.restartText) this.restartText.destroy();\r\n        if (this.continueText) this.continueText.destroy();\r\n        if (this.newRecordText) this.newRecordText.destroy();\r\n        if (this.menuText) this.menuText.destroy();\r\n    }\r\n}\r\n","import type { Position, Obstacle } from '../types/game.types';\r\n\r\n/**\r\n * Sistema de colisiones optimizado con mapa pre-calculado\r\n * Proporciona queries rápidas O(1) para detección de colisiones\r\n */\r\nexport class CollisionSystem {\r\n    private boardSize: number;\r\n    private collisionMap: boolean[][] | null = null;\r\n\r\n    constructor(boardSize: number) {\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Construye el mapa de colisiones basado en obstáculos\r\n     */\r\n    build(obstacles: Obstacle[]): void {\r\n        if (!this.boardSize || this.boardSize < 1) {\r\n            console.error('CollisionSystem.build: Invalid boardSize:', this.boardSize);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            this.collisionMap = Array.from(\r\n                { length: this.boardSize },\r\n                () => Array(this.boardSize).fill(false)\r\n            );\r\n\r\n            obstacles.forEach(obstacle => {\r\n                if (this.isWithinBounds(obstacle.x, obstacle.y)) {\r\n                    this.collisionMap![obstacle.y][obstacle.x] = true;\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.error('Error building collision map:', error);\r\n            this.collisionMap = Array.from(\r\n                { length: this.boardSize },\r\n                () => Array(this.boardSize).fill(false)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Verifica si una posición tiene colisión (obstáculo o fuera de límites)\r\n     */\r\n    isCollision(x: number, y: number): boolean {\r\n        if (this.isOutOfBounds(x, y)) {\r\n            return true;\r\n        }\r\n        return this.collisionMap?.[y]?.[x] ?? false;\r\n    }\r\n\r\n    /**\r\n     * Verifica si una posición contiene una trampa\r\n     */\r\n    isTrap(x: number, y: number, traps: Position[]): boolean {\r\n        if (this.isOutOfBounds(x, y)) {\r\n            return false;\r\n        }\r\n        return traps.some(trap => trap.x === x && trap.y === y);\r\n    }\r\n\r\n    /**\r\n     * Verifica si las coordenadas están fuera del tablero\r\n     */\r\n    isOutOfBounds(x: number, y: number): boolean {\r\n        return x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize;\r\n    }\r\n\r\n    /**\r\n     * Verifica si las coordenadas están dentro del tablero\r\n     */\r\n    isWithinBounds(x: number, y: number): boolean {\r\n        return x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize;\r\n    }\r\n\r\n    /**\r\n     * Calcula el movimiento hasta encontrar un obstáculo\r\n     * Devuelve la posición final y la distancia recorrida\r\n     */\r\n    calculateMoveUntilObstacle(\r\n        startX: number,\r\n        startY: number,\r\n        dx: number,\r\n        dy: number\r\n    ): { x: number; y: number; distance: number } {\r\n        let currentX = startX;\r\n        let currentY = startY;\r\n        let distance = 0;\r\n\r\n        while (true) {\r\n            const nextX = currentX + dx;\r\n            const nextY = currentY + dy;\r\n\r\n            if (this.isCollision(nextX, nextY)) {\r\n                break;\r\n            }\r\n\r\n            currentX = nextX;\r\n            currentY = nextY;\r\n            distance++;\r\n        }\r\n\r\n        return { x: currentX, y: currentY, distance };\r\n    }\r\n\r\n    /**\r\n     * Verifica si el camino entre dos puntos está libre\r\n     */\r\n    isPathClear(start: Position, end: Position, obstacles: Obstacle[]): boolean {\r\n        const dx = Math.sign(end.x - start.x);\r\n        const dy = Math.sign(end.y - start.y);\r\n\r\n        let currX = start.x;\r\n        let currY = start.y;\r\n\r\n        while (currX !== end.x || currY !== end.y) {\r\n            currX += dx;\r\n            currY += dy;\r\n\r\n            if (obstacles.some(o => o.x === currX && o.y === currY)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Actualiza el tamaño del tablero\r\n     */\r\n    setBoardSize(size: number): void {\r\n        this.boardSize = size;\r\n        this.collisionMap = null;\r\n    }\r\n\r\n    /**\r\n     * Obtiene el tamaño del tablero\r\n     */\r\n    getBoardSize(): number {\r\n        return this.boardSize;\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { generateFreePosition } from '../utils/Utils';\r\nimport type { Position, Obstacle } from '../types/game.types';\r\n\r\n/**\r\n * Datos generados del laberinto\r\n */\r\nexport interface MazeData {\r\n    coins: Position[];\r\n    obstacles: Obstacle[];\r\n    traps: Position[];\r\n    exitPosition: Position;\r\n}\r\n\r\n/**\r\n * Generador procedural de laberintos con validación de solvability\r\n */\r\nexport class MazeGenerator {\r\n    private boardSize: number;\r\n\r\n    constructor(boardSize: number) {\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Genera un laberinto completo válido (garantiza que sea solucionable)\r\n     */\r\n    generate(exitPosition: Position): MazeData {\r\n        const playerStart: Position = { x: 0, y: 0 };\r\n\r\n        let attempts = 0;\r\n        const maxAttempts = CONFIG.MAZE_GENERATION.MAX_ATTEMPTS;\r\n        let mazeData: MazeData;\r\n\r\n        do {\r\n            attempts++;\r\n            mazeData = this.generateAttempt(playerStart, exitPosition);\r\n        } while (!this.isSolvable(playerStart, exitPosition, mazeData) && attempts < maxAttempts);\r\n\r\n        if (attempts >= maxAttempts) {\r\n            console.warn('MazeGenerator: Max attempts reached, generating simple maze');\r\n            return this.generateSimpleMaze(exitPosition);\r\n        }\r\n\r\n        return mazeData;\r\n    }\r\n\r\n    /**\r\n     * Genera una posición aleatoria para la salida en el borde derecho o inferior\r\n     */\r\n    generateRandomExit(): Position {\r\n        const side = Math.floor(Math.random() * 2);\r\n        if (side === 0) {\r\n            return { x: this.boardSize - 1, y: Math.floor(Math.random() * this.boardSize) };\r\n        } else {\r\n            return { x: Math.floor(Math.random() * this.boardSize), y: this.boardSize - 1 };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Genera un save item en una posición válida\r\n     */\r\n    generateSaveItem(excludePositions: Position[]): Position | null {\r\n        return generateFreePosition(excludePositions, this.boardSize);\r\n    }\r\n\r\n    /**\r\n     * Un intento de generación de laberinto\r\n     */\r\n    private generateAttempt(playerStart: Position, exitPosition: Position): MazeData {\r\n        const coins: Position[] = [];\r\n        const obstacles: Obstacle[] = [];\r\n        const traps: Position[] = [];\r\n\r\n        for (let y = 0; y < this.boardSize; y++) {\r\n            for (let x = 0; x < this.boardSize; x++) {\r\n                // Skip player start and exit\r\n                if ((x === playerStart.x && y === playerStart.y) ||\r\n                    (x === exitPosition.x && y === exitPosition.y)) {\r\n                    continue;\r\n                }\r\n\r\n                if (Math.random() < CONFIG.MAZE_GENERATION.OBSTACLE_PROBABILITY &&\r\n                    this.hasEnoughSpace(x, y, obstacles, traps)) {\r\n                    const obstacleTypes: Array<'brick' | 'rock' | 'tree'> = ['brick', 'rock', 'tree'];\r\n                    const randomType = obstacleTypes[Phaser.Math.Between(0, obstacleTypes.length - 1)];\r\n                    obstacles.push({ x, y, type: randomType });\r\n                } else if (Math.random() < CONFIG.MAZE_GENERATION.COIN_PROBABILITY) {\r\n                    coins.push({ x, y });\r\n                } else if (Math.random() < CONFIG.MAZE_GENERATION.TRAP_PROBABILITY &&\r\n                    this.hasEnoughSpace(x, y, obstacles, traps)) {\r\n                    traps.push({ x, y });\r\n                }\r\n            }\r\n        }\r\n\r\n        return { coins, obstacles, traps, exitPosition };\r\n    }\r\n\r\n    /**\r\n     * Verifica que hay suficiente espacio alrededor de una posición\r\n     */\r\n    private hasEnoughSpace(x: number, y: number, obstacles: Obstacle[], traps: Position[]): boolean {\r\n        const directions = [\r\n            { x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 },\r\n            { x: -1, y: -1 }, { x: 1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: 1 }\r\n        ];\r\n\r\n        let freeSpaces = 0;\r\n        for (const dir of directions) {\r\n            const nx = x + dir.x;\r\n            const ny = y + dir.y;\r\n            if (\r\n                nx >= 0 && nx < this.boardSize &&\r\n                ny >= 0 && ny < this.boardSize &&\r\n                !obstacles.some(obs => obs.x === nx && obs.y === ny) &&\r\n                !traps.some(trap => trap.x === nx && trap.y === ny)\r\n            ) {\r\n                freeSpaces++;\r\n            }\r\n        }\r\n\r\n        return freeSpaces >= CONFIG.MAZE_GENERATION.MIN_FREE_SPACES;\r\n    }\r\n\r\n    /**\r\n     * Verifica que el laberinto es solucionable usando BFS\r\n     */\r\n    private isSolvable(playerStart: Position, exitPosition: Position, mazeData: MazeData): boolean {\r\n        const queue = [{ x: playerStart.x, y: playerStart.y }];\r\n        const visited = Array.from(\r\n            { length: this.boardSize },\r\n            () => Array(this.boardSize).fill(false)\r\n        );\r\n        visited[playerStart.y][playerStart.x] = true;\r\n\r\n        const directions = [\r\n            { x: 0, y: -1 },\r\n            { x: 1, y: 0 },\r\n            { x: 0, y: 1 },\r\n            { x: -1, y: 0 }\r\n        ];\r\n\r\n        while (queue.length > 0) {\r\n            const { x, y } = queue.shift()!;\r\n\r\n            if (x === exitPosition.x && y === exitPosition.y) {\r\n                return true;\r\n            }\r\n\r\n            for (const dir of directions) {\r\n                const nx = x + dir.x;\r\n                const ny = y + dir.y;\r\n\r\n                if (\r\n                    nx >= 0 && nx < this.boardSize &&\r\n                    ny >= 0 && ny < this.boardSize &&\r\n                    !visited[ny][nx] &&\r\n                    !mazeData.obstacles.some(obs => obs.x === nx && obs.y === ny) &&\r\n                    !mazeData.traps.some(trap => trap.x === nx && trap.y === ny)\r\n                ) {\r\n                    visited[ny][nx] = true;\r\n                    queue.push({ x: nx, y: ny });\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Genera un laberinto simple como fallback\r\n     */\r\n    private generateSimpleMaze(exitPosition: Position): MazeData {\r\n        return {\r\n            coins: [{ x: 2, y: 2 }, { x: 5, y: 5 }, { x: 7, y: 3 }],\r\n            obstacles: [\r\n                { x: 3, y: 4, type: 'brick' },\r\n                { x: 6, y: 7, type: 'rock' }\r\n            ],\r\n            traps: [],\r\n            exitPosition\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Actualiza el tamaño del tablero\r\n     */\r\n    setBoardSize(size: number): void {\r\n        this.boardSize = size;\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\nimport { calculateSpriteScale } from '../utils/Utils';\r\nimport type { Position, Obstacle, SpriteCache, GridSprite, ObstacleSprite } from '../types/game.types';\r\n\r\n/**\r\n * Datos de entidades para renderizar\r\n */\r\nexport interface RenderData {\r\n    coins: Position[];\r\n    obstacles: Obstacle[];\r\n    traps: Position[];\r\n    saves: Position[];      // Continue power-ups\r\n    shields: Position[];    // Shield power-ups\r\n    exitPosition: Position;\r\n}\r\n\r\n/**\r\n * Renderizador del grid y entidades del juego\r\n */\r\nexport class GridRenderer {\r\n    private scene: Phaser.Scene;\r\n    private cellSize: number;\r\n    private boardSize: number;\r\n    private gridGroup: Phaser.GameObjects.Group | null = null;\r\n    private spriteCache: SpriteCache = { coins: [], obstacles: [], traps: [] };\r\n\r\n    // Entity sprites\r\n    private coinSprites: GridSprite[] = [];\r\n    private obstacleSprites: ObstacleSprite[] = [];\r\n    private trapSprites: Phaser.GameObjects.Sprite[] = [];\r\n    private exitSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private saveSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private shieldSprite: Phaser.GameObjects.Sprite | null = null;\r\n    private exitPulseTween: Phaser.Tweens.Tween | null = null;\r\n    private savePulseTween: Phaser.Tweens.Tween | null = null;\r\n    private shieldPulseTween: Phaser.Tweens.Tween | null = null;\r\n\r\n    constructor(scene: Phaser.Scene, cellSize: number, boardSize: number) {\r\n        this.scene = scene;\r\n        this.cellSize = cellSize;\r\n        this.boardSize = boardSize;\r\n    }\r\n\r\n    /**\r\n     * Crea el grid visual según el nivel\r\n     */\r\n    createGrid(level: number): void {\r\n        this.scene.cameras.main.setBackgroundColor(CONFIG.UI.MAIN_BACKGROUND_COLOR);\r\n\r\n        const neonColor = CONFIG.BACKGROUND_COLORS[(level - 1) % CONFIG.BACKGROUND_COLORS.length];\r\n\r\n        if (this.gridGroup?.children) {\r\n            this.gridGroup.clear(true, true);\r\n        } else {\r\n            this.gridGroup = this.scene.add.group();\r\n        }\r\n\r\n        const graphics = this.scene.add.graphics();\r\n        graphics.lineStyle(1, neonColor, CONFIG.GRID_ALPHA);\r\n\r\n        for (let i = 0; i <= this.boardSize; i++) {\r\n            graphics.moveTo(i * this.cellSize, 0);\r\n            graphics.lineTo(i * this.cellSize, this.boardSize * this.cellSize);\r\n            graphics.moveTo(0, i * this.cellSize);\r\n            graphics.lineTo(this.boardSize * this.cellSize, i * this.cellSize);\r\n        }\r\n\r\n        graphics.strokePath();\r\n        this.gridGroup.add(graphics);\r\n\r\n        // Add dots at intersections\r\n        for (let y = 0; y < this.boardSize; y++) {\r\n            for (let x = 0; x < this.boardSize; x++) {\r\n                const dot = this.scene.add.rectangle(\r\n                    x * this.cellSize + this.cellSize / 2,\r\n                    y * this.cellSize + this.cellSize / 2,\r\n                    2, 2, neonColor\r\n                );\r\n                dot.setAlpha(0.6);\r\n                this.gridGroup.add(dot);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dibuja todas las entidades del laberinto\r\n     */\r\n    drawEntities(data: RenderData): void {\r\n        this.drawExit(data.exitPosition);\r\n        this.drawCoins(data.coins);\r\n        this.drawObstacles(data.obstacles);\r\n        this.drawTraps(data.traps);\r\n        this.drawSave(data.saves);\r\n        this.drawShield(data.shields);\r\n        this.hideUnusedSprites();\r\n    }\r\n\r\n    /**\r\n     * Dibuja la salida con animación pulsante\r\n     */\r\n    private drawExit(exitPosition: Position): void {\r\n        if (!this.exitSprite) {\r\n            this.exitSprite = this.scene.add.sprite(\r\n                exitPosition.x * this.cellSize + this.cellSize / 2,\r\n                exitPosition.y * this.cellSize + this.cellSize / 2,\r\n                'exit'\r\n            );\r\n        } else {\r\n            this.exitSprite.setPosition(\r\n                exitPosition.x * this.cellSize + this.cellSize / 2,\r\n                exitPosition.y * this.cellSize + this.cellSize / 2\r\n            );\r\n            this.exitSprite.setVisible(true);\r\n        }\r\n\r\n        const exitScale = calculateSpriteScale('exit', this.cellSize, this.scene);\r\n        this.exitSprite.setScale(exitScale);\r\n        this.startExitAnimation(exitScale);\r\n    }\r\n\r\n    /**\r\n     * Inicia la animación pulsante de la salida\r\n     */\r\n    private startExitAnimation(baseScale: number): void {\r\n        if (!this.exitSprite) return;\r\n\r\n        if (this.exitPulseTween) {\r\n            this.exitPulseTween.stop();\r\n        }\r\n\r\n        this.exitPulseTween = this.scene.tweens.add({\r\n            targets: this.exitSprite,\r\n            scaleX: { from: baseScale * 0.95, to: baseScale * 1.1 },\r\n            scaleY: { from: baseScale * 0.95, to: baseScale * 1.1 },\r\n            alpha: { from: 0.7, to: 1.0 },\r\n            duration: 800,\r\n            ease: 'Sine.InOut',\r\n            yoyo: true,\r\n            repeat: -1\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja las monedas\r\n     */\r\n    private drawCoins(coins: Position[]): void {\r\n        this.coinSprites = [];\r\n        coins.forEach((coin, index) => {\r\n            let coinSprite: GridSprite;\r\n\r\n            if (this.spriteCache.coins[index]?.active) {\r\n                coinSprite = this.spriteCache.coins[index] as GridSprite;\r\n                coinSprite.setPosition(\r\n                    coin.x * this.cellSize + this.cellSize / 2,\r\n                    coin.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                coinSprite.setVisible(true);\r\n            } else {\r\n                coinSprite = this.scene.add.sprite(\r\n                    coin.x * this.cellSize + this.cellSize / 2,\r\n                    coin.y * this.cellSize + this.cellSize / 2,\r\n                    'coin'\r\n                ) as GridSprite;\r\n                const coinScale = calculateSpriteScale('coin', this.cellSize, this.scene);\r\n                coinSprite.setScale(coinScale);\r\n                this.spriteCache.coins[index] = coinSprite;\r\n            }\r\n\r\n            coinSprite.gridX = coin.x;\r\n            coinSprite.gridY = coin.y;\r\n            this.coinSprites.push(coinSprite);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja los obstáculos\r\n     */\r\n    private drawObstacles(obstacles: Obstacle[]): void {\r\n        this.obstacleSprites = [];\r\n        obstacles.forEach((obstacle, index) => {\r\n            let obstacleSprite: ObstacleSprite;\r\n\r\n            if (this.spriteCache.obstacles[index]?.active) {\r\n                obstacleSprite = this.spriteCache.obstacles[index] as ObstacleSprite;\r\n                obstacleSprite.setPosition(\r\n                    obstacle.x * this.cellSize + this.cellSize / 2,\r\n                    obstacle.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                obstacleSprite.setTexture(`obstacle_${obstacle.type}`);\r\n                obstacleSprite.setVisible(true);\r\n            } else {\r\n                obstacleSprite = this.scene.add.sprite(\r\n                    obstacle.x * this.cellSize + this.cellSize / 2,\r\n                    obstacle.y * this.cellSize + this.cellSize / 2,\r\n                    `obstacle_${obstacle.type}`\r\n                ) as ObstacleSprite;\r\n                const obstacleScale = calculateSpriteScale(`obstacle_${obstacle.type}`, this.cellSize, this.scene);\r\n                obstacleSprite.setScale(obstacleScale);\r\n                this.spriteCache.obstacles[index] = obstacleSprite;\r\n            }\r\n\r\n            obstacleSprite.obstacleType = obstacle.type;\r\n            obstacleSprite.gridX = obstacle.x;\r\n            obstacleSprite.gridY = obstacle.y;\r\n            this.obstacleSprites.push(obstacleSprite);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja las trampas con animación de giro\r\n     */\r\n    private drawTraps(traps: Position[]): void {\r\n        this.trapSprites = [];\r\n        traps.forEach((trap, index) => {\r\n            let trapSprite: Phaser.GameObjects.Sprite;\r\n\r\n            if (this.spriteCache.traps[index]?.active) {\r\n                trapSprite = this.spriteCache.traps[index];\r\n                trapSprite.setPosition(\r\n                    trap.x * this.cellSize + this.cellSize / 2,\r\n                    trap.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                trapSprite.setVisible(true);\r\n            } else {\r\n                trapSprite = this.scene.add.sprite(\r\n                    trap.x * this.cellSize + this.cellSize / 2,\r\n                    trap.y * this.cellSize + this.cellSize / 2,\r\n                    'trap'\r\n                );\r\n                const trapScale = calculateSpriteScale('trap', this.cellSize, this.scene);\r\n                trapSprite.setScale(trapScale);\r\n                this.spriteCache.traps[index] = trapSprite;\r\n            }\r\n\r\n            // Spinning animation with staggered start\r\n            const staggerDelay = Phaser.Math.Between(0, 2000);\r\n            this.scene.time.delayedCall(staggerDelay, () => {\r\n                if (trapSprite?.active) {\r\n                    this.scene.tweens.add({\r\n                        targets: trapSprite,\r\n                        angle: 360,\r\n                        duration: 1500,\r\n                        ease: 'Cubic.InOut',\r\n                        repeat: -1,\r\n                        onRepeat: () => trapSprite.setAngle(0)\r\n                    });\r\n                }\r\n            });\r\n\r\n            this.trapSprites.push(trapSprite);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Dibuja el save item con animación pulsante\r\n     */\r\n    private drawSave(saves: Position[]): void {\r\n        if (saves.length > 0) {\r\n            const save = saves[0];\r\n            if (!this.saveSprite) {\r\n                this.saveSprite = this.scene.add.sprite(\r\n                    save.x * this.cellSize + this.cellSize / 2,\r\n                    save.y * this.cellSize + this.cellSize / 2,\r\n                    'power_continue'\r\n                );\r\n            } else {\r\n                this.saveSprite.setPosition(\r\n                    save.x * this.cellSize + this.cellSize / 2,\r\n                    save.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                this.saveSprite.setVisible(true);\r\n            }\r\n\r\n            const saveScale = calculateSpriteScale('power_continue', this.cellSize, this.scene);\r\n            this.saveSprite.setScale(saveScale);\r\n            this.saveSprite.setAlpha(1);\r\n\r\n            if (this.savePulseTween) {\r\n                this.savePulseTween.stop();\r\n            }\r\n\r\n            this.savePulseTween = this.scene.tweens.add({\r\n                targets: this.saveSprite,\r\n                scaleX: { from: saveScale * 0.95, to: saveScale * 1.08 },\r\n                scaleY: { from: saveScale * 0.95, to: saveScale * 1.08 },\r\n                alpha: { from: 0.9, to: 1.0 },\r\n                ease: 'Sine.InOut',\r\n                duration: 600,\r\n                yoyo: true,\r\n                repeat: -1\r\n            });\r\n        } else if (this.saveSprite) {\r\n            this.saveSprite.setVisible(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dibuja el shield item con animación pulsante\r\n     */\r\n    private drawShield(shields: Position[]): void {\r\n        if (shields.length > 0) {\r\n            const shield = shields[0];\r\n            if (!this.shieldSprite) {\r\n                this.shieldSprite = this.scene.add.sprite(\r\n                    shield.x * this.cellSize + this.cellSize / 2,\r\n                    shield.y * this.cellSize + this.cellSize / 2,\r\n                    'power_shield'\r\n                );\r\n            } else {\r\n                this.shieldSprite.setPosition(\r\n                    shield.x * this.cellSize + this.cellSize / 2,\r\n                    shield.y * this.cellSize + this.cellSize / 2\r\n                );\r\n                this.shieldSprite.setVisible(true);\r\n            }\r\n\r\n            const shieldScale = calculateSpriteScale('power_shield', this.cellSize, this.scene);\r\n            this.shieldSprite.setScale(shieldScale);\r\n            this.shieldSprite.setAlpha(1);\r\n\r\n            if (this.shieldPulseTween) {\r\n                this.shieldPulseTween.stop();\r\n            }\r\n\r\n            this.shieldPulseTween = this.scene.tweens.add({\r\n                targets: this.shieldSprite,\r\n                scaleX: { from: shieldScale * 0.95, to: shieldScale * 1.08 },\r\n                scaleY: { from: shieldScale * 0.95, to: shieldScale * 1.08 },\r\n                alpha: { from: 0.9, to: 1.0 },\r\n                ease: 'Sine.InOut',\r\n                duration: 600,\r\n                yoyo: true,\r\n                repeat: -1\r\n            });\r\n        } else if (this.shieldSprite) {\r\n            this.shieldSprite.setVisible(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Oculta sprites no usados del cache\r\n     */\r\n    private hideUnusedSprites(): void {\r\n        this.hideUnused(this.coinSprites, 'coins');\r\n        this.hideUnused(this.obstacleSprites, 'obstacles');\r\n        this.hideUnused(this.trapSprites, 'traps');\r\n    }\r\n\r\n    private hideUnused(usedSprites: Phaser.GameObjects.Sprite[], cacheKey: keyof SpriteCache): void {\r\n        const cache = this.spriteCache[cacheKey];\r\n        for (let i = usedSprites.length; i < cache.length; i++) {\r\n            if (cache[i]) {\r\n                cache[i].setVisible(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Anima los árboles cercanos cuando el jugador pasa\r\n     */\r\n    animateNearbyTrees(playerX: number, playerY: number): void {\r\n        this.obstacleSprites.forEach(sprite => {\r\n            if (sprite.obstacleType !== 'tree') return;\r\n\r\n            const distX = Math.abs((sprite.gridX ?? 0) - playerX);\r\n            const distY = Math.abs((sprite.gridY ?? 0) - playerY);\r\n\r\n            if (distX <= 1 && distY <= 1 && (distX + distY) > 0) {\r\n                if (!sprite.isSwaying) {\r\n                    sprite.isSwaying = true;\r\n                    const swayDirection = playerX < (sprite.gridX ?? 0) ? -1 : 1;\r\n\r\n                    this.scene.tweens.add({\r\n                        targets: sprite,\r\n                        angle: { from: 0, to: swayDirection * 8 },\r\n                        duration: 150,\r\n                        ease: 'Sine.InOut',\r\n                        yoyo: true,\r\n                        repeat: 1,\r\n                        onComplete: () => {\r\n                            sprite.setAngle(0);\r\n                            sprite.isSwaying = false;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Elimina una moneda del renderer\r\n     */\r\n    removeCoin(x: number, y: number): void {\r\n        for (let i = this.coinSprites.length - 1; i >= 0; i--) {\r\n            if (this.coinSprites[i].gridX === x && this.coinSprites[i].gridY === y) {\r\n                this.coinSprites[i].destroy();\r\n                this.coinSprites.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Elimina el save sprite\r\n     */\r\n    removeSave(): void {\r\n        if (this.savePulseTween) {\r\n            this.savePulseTween.stop();\r\n            this.savePulseTween = null;\r\n        }\r\n        if (this.saveSprite) {\r\n            this.saveSprite.destroy();\r\n            this.saveSprite = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Elimina el shield sprite\r\n     */\r\n    removeShield(): void {\r\n        if (this.shieldPulseTween) {\r\n            this.shieldPulseTween.stop();\r\n            this.shieldPulseTween = null;\r\n        }\r\n        if (this.shieldSprite) {\r\n            this.shieldSprite.destroy();\r\n            this.shieldSprite = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Obtiene los sprites de monedas\r\n     */\r\n    getCoinSprites(): GridSprite[] {\r\n        return this.coinSprites;\r\n    }\r\n\r\n    /**\r\n     * Obtiene los sprites de obstáculos\r\n     */\r\n    getObstacleSprites(): ObstacleSprite[] {\r\n        return this.obstacleSprites;\r\n    }\r\n\r\n    /**\r\n     * Limpia el cache de sprites\r\n     */\r\n    clearCache(): void {\r\n        Object.keys(this.spriteCache).forEach(key => {\r\n            const cacheKey = key as keyof SpriteCache;\r\n            this.spriteCache[cacheKey].forEach(sprite => {\r\n                if (sprite?.destroy) {\r\n                    sprite.destroy();\r\n                }\r\n            });\r\n            this.spriteCache[cacheKey] = [];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Destructor\r\n     */\r\n    destroy(): void {\r\n        this.clearCache();\r\n        if (this.exitPulseTween) this.exitPulseTween.stop();\r\n        if (this.savePulseTween) this.savePulseTween.stop();\r\n        if (this.shieldPulseTween) this.shieldPulseTween.stop();\r\n        if (this.exitSprite) this.exitSprite.destroy();\r\n        if (this.saveSprite) this.saveSprite.destroy();\r\n        if (this.shieldSprite) this.shieldSprite.destroy();\r\n        if (this.gridGroup) this.gridGroup.clear(true, true);\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from '../Config';\r\n\r\n// Managers\r\nimport { InputManager } from '../managers/InputManager';\r\nimport { AudioManager } from '../managers/AudioManager';\r\nimport { PlayerController } from '../managers/PlayerController';\r\nimport { EnemyManager } from '../managers/EnemyManager';\r\nimport { SpiderManager } from '../managers/SpiderManager';\r\nimport { UIManager } from '../managers/UIManager';\r\nimport { GameStateManager } from '../managers/GameStateManager';\r\n\r\n// Systems\r\nimport { CollisionSystem } from '../systems/CollisionSystem';\r\nimport { MazeGenerator, type MazeData } from '../systems/MazeGenerator';\r\nimport { GridRenderer } from '../systems/GridRenderer';\r\n\r\nimport type { Position, Direction } from '../types/game.types';\r\n\r\n/**\r\n * Escena principal del juego - Actúa como orquestador de todos los managers\r\n */\r\nexport class GameScene extends Phaser.Scene {\r\n    // Configuration\r\n    private boardSize: number;\r\n    private cellSize: number;\r\n\r\n    // Managers\r\n    private inputManager!: InputManager;\r\n    private audioManager!: AudioManager;\r\n    private playerController!: PlayerController;\r\n    private enemyManager!: EnemyManager;\r\n    private spiderManager!: SpiderManager;\r\n    private uiManager!: UIManager;\r\n    private gameState!: GameStateManager;\r\n\r\n    // Systems\r\n    private collision!: CollisionSystem;\r\n    private mazeGenerator!: MazeGenerator;\r\n    private gridRenderer!: GridRenderer;\r\n\r\n    // Game Data\r\n    private mazeData!: MazeData;\r\n    private saves: Position[] = [];      // Continue power-ups\r\n    private shields: Position[] = [];    // Shield power-ups\r\n    private playerStartPosition: Position = { x: 0, y: 0 };\r\n    private shieldSpawned: boolean = false;   // Track if shield already spawned this level\r\n    private continueSpawned: boolean = false; // Track if continue already spawned this level\r\n\r\n    // Optimization\r\n    private lastEnemyUpdateTime: number = 0;\r\n    private requireFreshPressAfterReset: boolean = false;\r\n\r\n    constructor() {\r\n        super('GameScene');\r\n        this.boardSize = CONFIG.BOARD_SIZE;\r\n        this.cellSize = CONFIG.CELL_SIZE;\r\n    }\r\n\r\n    preload(): void {\r\n        try {\r\n            // Load images\r\n            this.load.image('player_stand', 'lucy_stand.png');\r\n            this.load.image('player_run', 'lucy_run.png');\r\n            this.load.image('player_die', 'lucy_die.png');\r\n            this.load.image('coin', 'coin_tuto.png');\r\n            this.load.image('obstacle_brick', 'brick_1.png');\r\n            this.load.image('obstacle_rock', 'rock_1.png');\r\n            this.load.image('obstacle_tree', 'tree_1.png');\r\n            this.load.image('trap', 'sping.png');\r\n            this.load.image('exit', 'exit.png');\r\n            this.load.image('enemy', 'enemy.png');\r\n            this.load.image('spider', 'enemy_spider.png');\r\n            this.load.image('power_continue', 'power_continue.png');\r\n            this.load.image('power_shield', 'power_shield.png');\r\n\r\n            // Initialize audio manager early for preload\r\n            this.audioManager = new AudioManager(this);\r\n            this.audioManager.detectAndLoadMusic();\r\n        } catch (error) {\r\n            console.error('Critical error in preload:', error);\r\n        }\r\n    }\r\n\r\n    create(): void {\r\n        // Initialize all managers and systems\r\n        this.initializeManagers();\r\n\r\n        // Setup event listeners\r\n        this.setupEvents();\r\n\r\n        // Generate initial maze\r\n        this.startNewGame();\r\n\r\n        // Initialize audio\r\n        this.audioManager.initMusic();\r\n\r\n        // Setup UI event listeners\r\n        this.uiManager.setupEventListeners({\r\n            onMusicToggle: () => this.audioManager.togglePlayPause(),\r\n            onVolumeChange: (vol) => this.audioManager.setVolume(vol),\r\n            onNextMusic: () => this.audioManager.playNext(),\r\n            onPrevMusic: () => this.audioManager.playPrevious(),\r\n            onRestart: () => this.handleRestartButton()\r\n        });\r\n\r\n        // Update initial UI\r\n        this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n    }\r\n\r\n    update(time: number, _delta: number): void {\r\n        // Handle game over input\r\n        if (this.gameState.isGameOver) {\r\n            // R = Full restart (reset everything)\r\n            if (this.inputManager.isRestartJustPressed()) {\r\n                this.gameState.reset(true);\r\n                this.updatePowerUpsUI();\r\n                this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n                this.resetGame(true);\r\n            }\r\n            // C = Continue (use power-up, keep level and score)\r\n            if (this.inputManager.isContinueJustPressed() && this.gameState.useContinue()) {\r\n                this.updatePowerUpsUI();\r\n                this.resetGame(false);\r\n            }\r\n            if (this.inputManager.isMenuJustPressed()) {\r\n                this.returnToMenu();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Update enemies with throttling\r\n        if (time > this.lastEnemyUpdateTime + CONFIG.PERFORMANCE.ENEMY_UPDATE_THROTTLE_MS) {\r\n            this.enemyManager.update();\r\n\r\n            // Update spiders and check collision\r\n            const playerPos = this.playerController.getPosition();\r\n            const playerHit = this.spiderManager.update(time, playerPos);\r\n            if (playerHit && !this.gameState.isGameOver) {\r\n                this.handleDeath();\r\n            }\r\n\r\n            this.lastEnemyUpdateTime = time;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Inicializa todos los managers y sistemas\r\n     */\r\n    private initializeManagers(): void {\r\n        // Core systems\r\n        this.collision = new CollisionSystem(this.boardSize);\r\n        this.mazeGenerator = new MazeGenerator(this.boardSize);\r\n        this.gridRenderer = new GridRenderer(this, this.cellSize, this.boardSize);\r\n\r\n        // Managers\r\n        this.inputManager = new InputManager(this);\r\n        // audioManager already initialized in preload\r\n        this.playerController = new PlayerController(this, this.collision, this.cellSize);\r\n        this.enemyManager = new EnemyManager(this, this.collision, this.cellSize);\r\n        this.spiderManager = new SpiderManager(this, this.collision, this.cellSize, this.boardSize);\r\n        this.uiManager = new UIManager();\r\n        this.gameState = new GameStateManager(this);\r\n\r\n        // Setup input\r\n        this.inputManager.setup();\r\n\r\n        // Setup turn callbacks for direction change during movement\r\n        this.playerController.setTurnCallbacks(\r\n            () => this.inputManager.getDesiredDirection(),\r\n            (dx, dy) => this.handlePlayerMove({ dx, dy })\r\n        );\r\n\r\n        // Create game over UI\r\n        this.gameState.createGameOverUI();\r\n    }\r\n\r\n    /**\r\n     * Configura los eventos entre managers\r\n     */\r\n    private setupEvents(): void {\r\n        // Input direction event\r\n        this.events.on('input:direction', (direction: Direction) => {\r\n            if (!this.playerController.getIsMoving() &&\r\n                !this.gameState.isGameOver &&\r\n                (direction.dx !== 0 || direction.dy !== 0)) {\r\n                this.handlePlayerMove(direction);\r\n                this.requireFreshPressAfterReset = false;\r\n            }\r\n        });\r\n\r\n        // Player events\r\n        this.events.on('player:died', () => {\r\n            this.handleDeath();\r\n        });\r\n\r\n        this.events.on('player:reachedExit', () => {\r\n            this.handleLevelComplete();\r\n        });\r\n\r\n        // Enemy moved event (check collision with player)\r\n        this.events.on('enemy:moved', (pos: Position) => {\r\n            const playerPos = this.playerController.getPosition();\r\n            if (pos.x === playerPos.x && pos.y === playerPos.y) {\r\n                this.handleDeath();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Inicia un nuevo juego\r\n     */\r\n    private startNewGame(): void {\r\n        // Generate maze\r\n        const exitPosition = this.mazeGenerator.generateRandomExit();\r\n        this.mazeData = this.mazeGenerator.generate(exitPosition);\r\n        this.saves = [];\r\n\r\n        // Build collision map\r\n        this.collision.build(this.mazeData.obstacles);\r\n\r\n        // Store initial coin count\r\n        this.gameState.initialCoinCount = this.mazeData.coins.length;\r\n\r\n        // Create grid and draw entities\r\n        this.gridRenderer.createGrid(this.gameState.level);\r\n        this.gridRenderer.drawEntities({\r\n            coins: this.mazeData.coins,\r\n            obstacles: this.mazeData.obstacles,\r\n            traps: this.mazeData.traps,\r\n            saves: this.saves,\r\n            shields: this.shields,\r\n            exitPosition: this.mazeData.exitPosition\r\n        });\r\n\r\n        // Create player\r\n        this.playerController.create(this.playerStartPosition);\r\n\r\n        // Initialize enemies (level 5+)\r\n        const excludePositions = [\r\n            this.playerStartPosition,\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps\r\n        ];\r\n        this.enemyManager.init(this.gameState.level, excludePositions);\r\n\r\n        // Initialize spiders\r\n        this.spiderManager.generate(\r\n            this.gameState.level,\r\n            this.mazeData.obstacles,\r\n            this.mazeData.exitPosition\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Maneja el movimiento del jugador\r\n     */\r\n    private handlePlayerMove(direction: Direction): void {\r\n        this.playerController.move(\r\n            direction.dx,\r\n            direction.dy,\r\n            this.gameState.level,\r\n            this.mazeData.traps,\r\n            this.mazeData.exitPosition,\r\n            (x, y) => this.enemyManager.checkCollision(x, y) || this.spiderManager.checkCollision(x, y),\r\n            (x, y) => this.processItemsAtPosition(x, y)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Procesa items en la posición del jugador\r\n     */\r\n    private processItemsAtPosition(x: number, y: number): void {\r\n        // Check coins\r\n        for (let i = this.mazeData.coins.length - 1; i >= 0; i--) {\r\n            if (this.mazeData.coins[i].x === x && this.mazeData.coins[i].y === y) {\r\n                this.playerController.emitCoinParticles(x, y);\r\n                this.mazeData.coins.splice(i, 1);\r\n                this.gameState.addScore(10);\r\n                this.uiManager.updateScore(this.gameState.score);\r\n                this.gridRenderer.removeCoin(x, y);\r\n\r\n                // Check power-up spawn triggers based on coins collected\r\n                if (this.gameState.initialCoinCount > 0) {\r\n                    const collected = this.gameState.initialCoinCount - this.mazeData.coins.length;\r\n                    const ratio = collected / this.gameState.initialCoinCount;\r\n\r\n                    // Power-up spawns at configured ratio (only ONE per level)\r\n                    if (ratio >= CONFIG.POWERUPS.SPAWN_COIN_RATIO && !this.shieldSpawned && !this.continueSpawned) {\r\n                        // Shield has higher probability than continue\r\n                        if (Math.random() < CONFIG.POWERUPS.SHIELD_PROBABILITY) {\r\n                            this.generateShieldItem();\r\n                            this.shieldSpawned = true;\r\n                        } else {\r\n                            this.generateSaveItem();\r\n                            this.continueSpawned = true;\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Check shield collection\r\n        if (this.shields.length > 0) {\r\n            const shield = this.shields[0];\r\n            if (shield.x === x && shield.y === y) {\r\n                this.gameState.addShield();\r\n                this.shields.splice(0, 1);\r\n                this.gridRenderer.removeShield();\r\n                this.updatePowerUpsUI();\r\n            }\r\n        }\r\n\r\n        // Check continue collection\r\n        if (this.saves.length > 0) {\r\n            const save = this.saves[0];\r\n            if (save.x === x && save.y === y) {\r\n                this.gameState.addContinue();\r\n                this.saves.splice(0, 1);\r\n                this.gridRenderer.removeSave();\r\n                this.updatePowerUpsUI();\r\n            }\r\n        }\r\n\r\n        // Animate nearby trees\r\n        this.gridRenderer.animateNearbyTrees(x, y);\r\n    }\r\n\r\n    /**\r\n     * Genera un save item (continue power-up)\r\n     */\r\n    private generateSaveItem(): void {\r\n        const excludePositions = [\r\n            this.playerController.getPosition(),\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps,\r\n            ...this.enemyManager.getEnemies().map(e => ({ x: e.x, y: e.y })),\r\n            ...this.shields\r\n        ];\r\n\r\n        const position = this.mazeGenerator.generateSaveItem(excludePositions);\r\n        if (position && this.saves.length === 0) {\r\n            this.saves.push(position);\r\n            this.gridRenderer.drawEntities({\r\n                coins: this.mazeData.coins,\r\n                obstacles: this.mazeData.obstacles,\r\n                traps: this.mazeData.traps,\r\n                saves: this.saves,\r\n                shields: this.shields,\r\n                exitPosition: this.mazeData.exitPosition\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Genera un shield item\r\n     */\r\n    private generateShieldItem(): void {\r\n        const excludePositions = [\r\n            this.playerController.getPosition(),\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps,\r\n            ...this.enemyManager.getEnemies().map(e => ({ x: e.x, y: e.y })),\r\n            ...this.saves\r\n        ];\r\n\r\n        const position = this.mazeGenerator.generateSaveItem(excludePositions);\r\n        if (position && this.shields.length === 0) {\r\n            this.shields.push(position);\r\n            this.gridRenderer.drawEntities({\r\n                coins: this.mazeData.coins,\r\n                obstacles: this.mazeData.obstacles,\r\n                traps: this.mazeData.traps,\r\n                saves: this.saves,\r\n                shields: this.shields,\r\n                exitPosition: this.mazeData.exitPosition\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Maneja la muerte del jugador\r\n     * Primero intenta usar shield (flash sin detener), luego game over\r\n     */\r\n    private handleDeath(): void {\r\n        // Try to use shield first\r\n        if (this.gameState.useShield()) {\r\n            // Shield absorbed the hit - flash player and continue movement\r\n            this.playerController.flashInvincibility();\r\n            this.updatePowerUpsUI();\r\n            return;\r\n        }\r\n\r\n        // No shield - game over\r\n        this.gameState.isGameOver = true;\r\n        this.playerController.stopMovement();\r\n        this.playerController.showDeathSprite();\r\n        this.gameState.showGameOver();\r\n    }\r\n\r\n    /**\r\n     * Maneja la completación del nivel\r\n     */\r\n    private handleLevelComplete(): void {\r\n        this.gameState.nextLevel();\r\n        this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n        this.playerController.stopMovement();\r\n        this.requireFreshPressAfterReset = true;\r\n        this.inputManager.resetDesiredDirection();\r\n        this.resetGame(false);\r\n    }\r\n\r\n    /**\r\n     * Resetea el juego\r\n     */\r\n    private resetGame(fullReset: boolean): void {\r\n        // Clear caches\r\n        this.gridRenderer.clearCache();\r\n        this.enemyManager.reset();\r\n        this.spiderManager.reset();\r\n\r\n        // Generate new maze\r\n        const exitPosition = this.mazeGenerator.generateRandomExit();\r\n        this.mazeData = this.mazeGenerator.generate(exitPosition);\r\n\r\n        // Reset power-up items and spawn flags\r\n        this.saves = [];\r\n        this.shields = [];\r\n        this.shieldSpawned = false;\r\n        this.continueSpawned = false;\r\n\r\n        // Rebuild collision\r\n        this.collision.build(this.mazeData.obstacles);\r\n        this.gameState.initialCoinCount = this.mazeData.coins.length;\r\n\r\n        // Redraw\r\n        this.gridRenderer.createGrid(this.gameState.level);\r\n        this.gridRenderer.drawEntities({\r\n            coins: this.mazeData.coins,\r\n            obstacles: this.mazeData.obstacles,\r\n            traps: this.mazeData.traps,\r\n            saves: this.saves,\r\n            shields: this.shields,\r\n            exitPosition: this.mazeData.exitPosition\r\n        });\r\n\r\n        // Reset player\r\n        this.playerController.reset(this.playerStartPosition);\r\n\r\n        // Re-init enemies\r\n        const excludePositions = [\r\n            this.playerStartPosition,\r\n            this.mazeData.exitPosition,\r\n            ...this.mazeData.obstacles,\r\n            ...this.mazeData.traps\r\n        ];\r\n        this.enemyManager.init(this.gameState.level, excludePositions);\r\n        this.spiderManager.generate(\r\n            this.gameState.level,\r\n            this.mazeData.obstacles,\r\n            this.mazeData.exitPosition\r\n        );\r\n\r\n        // Hide game over UI\r\n        this.gameState.hideGameOverUI();\r\n    }\r\n\r\n    /**\r\n     * Maneja el botón de restart de UI\r\n     */\r\n    private handleRestartButton(): void {\r\n        if (this.gameState.useContinue()) {\r\n            this.updatePowerUpsUI();\r\n            this.resetGame(false);\r\n        } else {\r\n            this.gameState.reset(true);\r\n            this.updatePowerUpsUI();\r\n            this.uiManager.updateScoreAndLevel(this.gameState.score, this.gameState.level);\r\n            this.resetGame(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Actualiza la UI de power-ups\r\n     */\r\n    private updatePowerUpsUI(): void {\r\n        this.uiManager.updatePowerUps(\r\n            this.gameState.shieldCount,\r\n            this.gameState.continueCount\r\n        );\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Retorna al menú principal\r\n     */\r\n    private returnToMenu(): void {\r\n        this.audioManager.stop();\r\n        this.gameState.returnToMenu();\r\n    }\r\n\r\n    /**\r\n     * Cleanup al destruir la escena\r\n     */\r\n    shutdown(): void {\r\n        this.inputManager?.destroy();\r\n        this.audioManager?.destroy();\r\n        this.playerController?.destroy();\r\n        this.enemyManager?.destroy();\r\n        this.spiderManager?.destroy();\r\n        this.uiManager?.destroy();\r\n        this.gameState?.destroy();\r\n        this.gridRenderer?.destroy();\r\n\r\n        this.events.off('input:direction');\r\n        this.events.off('player:died');\r\n        this.events.off('player:reachedExit');\r\n        this.events.off('enemy:moved');\r\n    }\r\n}\r\n","import Phaser from 'phaser';\r\nimport { CONFIG } from './Config';\r\nimport { MenuScene } from './scenes/MenuScene';\r\nimport { GameScene } from './scenes/GameScene';\r\n\r\nconst config: Phaser.Types.Core.GameConfig = {\r\n    type: Phaser.AUTO,\r\n    width: CONFIG.GAME_WIDTH,\r\n    height: CONFIG.GAME_HEIGHT,\r\n    backgroundColor: CONFIG.UI.MAIN_BACKGROUND_COLOR,\r\n    parent: 'game-container',\r\n    pixelArt: true,\r\n    scale: {\r\n        mode: Phaser.Scale.FIT,\r\n        autoCenter: Phaser.Scale.CENTER_BOTH\r\n    },\r\n    scene: [MenuScene, GameScene]\r\n};\r\n\r\nnew Phaser.Game(config);\r\n"],"names":["CONFIG","HIGH_SCORE_KEY","ScoreManager","stored","score","current","MenuScene","Phaser","centerX","centerY","playerLogo","playButton","highScore","pointer","InputManager","scene","event","dx","dy","absDx","absDy","_a","AudioManager","maxTracks","file","keyIndex","key","i","filename","error","tryStartMusic","j","musicKey","soundManager","_b","volume","isPlaying","toggleButton","calculateSpriteScale","textureKey","targetSize","sourceImage","originalWidth","originalHeight","generateFreePosition","excludePositions","boardSize","maxAttempts","attempts","position","pos","PlayerController","collision","cellSize","getDesiredDirection","onTurnMove","level","traps","exitPosition","checkEnemyCollision","onStepCallback","moveResult","baseStepDuration","finalDestination","startX","startY","checkX","checkY","lastStepProcessed","tween","progress","currentStep","stepStart","step","newX","newY","gameState","desiredDirection","turnNextX","turnNextY","playerScale","x","y","dieScale","EnemyManager","enemyCount","secondEnemyLevel","allExcluded","e","enemy","enemyScale","index","nextX","nextY","wallCollision","enemyCollision","excludeIndex","playerX","playerY","directions","SpiderManager","obstacles","spiderCount","spiderAdded","pointA","axis","pointB","spider","spiderScale","time","playerPosition","playerHit","speed","p","o","s","UIManager","safeScore","scoreElement","safeLevel","levelElement","shields","continues","shieldsElement","continuesElement","callbacks","toggleMusicButton","volumeSlider","nextButton","prevButton","restartButton","addListener","element","handler","target","GameStateManager","isNewRecord","_c","menuOffsetY","_d","_e","points","fullReset","value","CollisionSystem","obstacle","trap","currentX","currentY","distance","start","end","currX","currY","size","MazeGenerator","playerStart","mazeData","coins","obstacleTypes","randomType","freeSpaces","dir","nx","ny","obs","queue","visited","GridRenderer","neonColor","graphics","dot","data","exitScale","baseScale","coin","coinSprite","coinScale","obstacleSprite","obstacleScale","trapSprite","trapScale","staggerDelay","saves","save","saveScale","shield","shieldScale","usedSprites","cacheKey","cache","sprite","distX","distY","swayDirection","GameScene","vol","_delta","playerPos","direction","_f","_g","_h","config"],"mappings":"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"}